/// <reference types="react" />
import { NoInfer } from '@tanstack/react-store';
import { ParsePathParams } from './link.js';
import { AnyRoute, ResolveFullPath, ResolveFullSearchSchema, MergeFromFromParent, RouteContext, AnyContext, UpdatableRouteOptions, Route, RootRouteId, TrimPathLeft, RouteConstraints, ResolveFullSearchSchemaInput, SearchSchemaInput, RouteLoaderFn, AnyPathParams, AnySearchSchema, FileBaseRouteOptions } from './route.js';
import { Assign, Expand, IsAny } from './utils.js';
import { RouteMatch } from './Matches.js';
import { RegisteredRouter } from './router.js';
import { RouteById, RouteIds } from './routeInfo.js';
export interface FileRoutesByPath {
}
type Replace<S extends string, From extends string, To extends string> = S extends `${infer Start}${From}${infer Rest}` ? `${Start}${To}${Replace<Rest, From, To>}` : S;
export type TrimLeft<T extends string, S extends string> = T extends `${S}${infer U}` ? U : T;
export type TrimRight<T extends string, S extends string> = T extends `${infer U}${S}` ? U : T;
export type Trim<T extends string, S extends string> = TrimLeft<TrimRight<T, S>, S>;
export type RemoveUnderScores<T extends string> = Replace<Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>, '/_', '/'>;
type RemoveRouteGroups<S extends string> = S extends `${infer Before}(${infer RouteGroup})${infer After}` ? RemoveRouteGroups<`${Before}${After}`> : S;
type NormalizeSlashes<S extends string> = S extends `${infer Before}//${infer After}` ? NormalizeSlashes<`${Before}/${After}`> : S;
type ReplaceFirstOccurrence<T extends string, Search extends string, Replacement extends string> = T extends `${infer Prefix}${Search}${infer Suffix}` ? `${Prefix}${Replacement}${Suffix}` : T;
export type ResolveFilePath<TParentRoute extends AnyRoute, TFilePath extends string> = TParentRoute['id'] extends RootRouteId ? TrimPathLeft<TFilePath> : ReplaceFirstOccurrence<TrimPathLeft<TFilePath>, TrimPathLeft<TParentRoute['types']['customId']>, ''>;
export type FileRoutePath<TParentRoute extends AnyRoute, TFilePath extends string> = ResolveFilePath<TParentRoute, TFilePath> extends `_${infer _}` ? '' : ResolveFilePath<TParentRoute, TFilePath> extends `/_${infer _}` ? '' : ResolveFilePath<TParentRoute, TFilePath>;
export declare function createFileRoute<TFilePath extends keyof FileRoutesByPath, TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'], TId extends RouteConstraints['TId'] = NormalizeSlashes<RemoveRouteGroups<TFilePath>>, TPath extends RouteConstraints['TPath'] = FileRoutePath<TParentRoute, TFilePath>, TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, NormalizeSlashes<RemoveRouteGroups<RemoveUnderScores<TPath>>>>>(path: TFilePath): <TSearchSchemaInput extends AnySearchSchema = {}, TSearchSchema extends AnySearchSchema = {}, TSearchSchemaUsed extends Record<string, any> = TSearchSchemaInput extends SearchSchemaInput ? Omit<TSearchSchemaInput, "__TSearchSchemaInput__"> : TSearchSchema, TFullSearchSchemaInput extends AnySearchSchema = Expand<Assign<Omit<import("./route").InferFullSearchSchemaInput<TParentRoute>, "__TRootSearchSchema__">, TSearchSchemaUsed>>, TFullSearchSchema extends AnySearchSchema = Expand<Assign<Omit<import("./route").InferFullSearchSchema<TParentRoute>, "__TRootSearchSchema__">, TSearchSchema>>, TParams extends Record<string, any> = Expand<Record<TrimLeft<TrimRight<import("./link").Split<TPath, true>[number], "_">, "_"> extends infer T ? T extends TrimLeft<TrimRight<import("./link").Split<TPath, true>[number], "_">, "_"> ? T extends `$${infer L}` ? L extends "" ? "_splat" : L : never : never : never, string>>, TAllParams extends Record<string, any> = IsAny<TParentRoute["types"]["allParams"], TParams, TParentRoute["types"]["allParams"] & TParams>, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = [TRouteContextReturn] extends [never] ? RouteContext : TRouteContextReturn, TAllContext extends Expand<Assign<IsAny<TParentRoute["types"]["allContext"], {}, TParentRoute["types"]["allContext"]>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute["types"]["allContext"], {}, TParentRoute["types"]["allContext"]>, TRouteContext>>, TRouterContext extends AnyContext = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends unknown = unknown, TLoaderData extends unknown = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn, TChildren extends unknown = unknown, TRouteTree extends AnyRoute = AnyRoute>(options?: (FileBaseRouteOptions<TParentRoute, TPath, TSearchSchemaInput, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn> & {
    caseSensitive?: boolean | undefined;
    wrapInSuspense?: boolean | undefined;
    component?: import("./route").RouteComponent<any> | undefined;
    errorComponent?: false | import("./route").ErrorRouteComponent | null | undefined;
    notFoundComponent?: import("./route").NotFoundRouteComponent | undefined;
    pendingComponent?: import("./route").RouteComponent<any> | undefined;
    pendingMs?: number | undefined;
    pendingMinMs?: number | undefined;
    staleTime?: number | undefined;
    gcTime?: number | undefined;
    preloadStaleTime?: number | undefined;
    preloadGcTime?: number | undefined;
    preSearchFilters?: import("./route").SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
    postSearchFilters?: import("./route").SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
    onError?: ((err: any) => void) | undefined;
    onEnter?: ((match: import("./Matches").AnyRouteMatch) => void) | undefined;
    onStay?: ((match: import("./Matches").AnyRouteMatch) => void) | undefined;
    onLeave?: ((match: import("./Matches").AnyRouteMatch) => void) | undefined;
    meta?: ((ctx: {
        params: TAllParams;
        loaderData: TLoaderData;
    }) => import("react").DetailedHTMLProps<import("react").MetaHTMLAttributes<HTMLMetaElement>, HTMLMetaElement>[] | Promise<import("react").DetailedHTMLProps<import("react").MetaHTMLAttributes<HTMLMetaElement>, HTMLMetaElement>[]>) | undefined;
    links?: (() => import("react").DetailedHTMLProps<import("react").LinkHTMLAttributes<HTMLLinkElement>, HTMLLinkElement>[]) | undefined;
    scripts?: (() => import("react").DetailedHTMLProps<import("react").ScriptHTMLAttributes<HTMLScriptElement>, HTMLScriptElement>[]) | undefined;
    headers?: ((ctx: {
        loaderData: TLoaderData;
    }) => Record<string, string> | Promise<Record<string, string>>) | undefined;
} & {
    staticData?: import("./route").StaticDataRouteOption | undefined;
}) | undefined) => Route<TParentRoute, TPath, TFullPath, TFilePath, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren, TRouteTree>;
/**
  @deprecated It's no longer recommended to use the `FileRoute` class directly.
  Instead, use `createFileRoute('/path/to/file')(options)` to create a file route.
*/
export declare class FileRoute<TFilePath extends keyof FileRoutesByPath, TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'], TId extends RouteConstraints['TId'] = TFilePath, TPath extends RouteConstraints['TPath'] = FileRoutePath<TParentRoute, TFilePath>, TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, RemoveUnderScores<TPath>>> {
    path: TFilePath;
    silent?: boolean;
    constructor(path: TFilePath, _opts?: {
        silent: boolean;
    });
    createRoute: <TSearchSchemaInput extends AnySearchSchema = {}, TSearchSchema extends AnySearchSchema = {}, TSearchSchemaUsed extends Record<string, any> = TSearchSchemaInput extends SearchSchemaInput ? Omit<TSearchSchemaInput, "__TSearchSchemaInput__"> : TSearchSchema, TFullSearchSchemaInput extends AnySearchSchema = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>, TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends Record<string, any> = Expand<Record<ParsePathParams<TPath>, string>>, TAllParams extends Record<string, any> = MergeFromFromParent<TParentRoute["types"]["allParams"], TParams>, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = [TRouteContextReturn] extends [never] ? RouteContext : TRouteContextReturn, TAllContext extends Expand<Assign<IsAny<TParentRoute["types"]["allContext"], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute["types"]["allContext"], {}>, TRouteContext>>, TRouterContext extends AnyContext = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends unknown = unknown, TLoaderData extends unknown = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn, TChildren extends unknown = unknown, TRouteTree extends AnyRoute = AnyRoute>(options?: (FileBaseRouteOptions<TParentRoute, TPath, TSearchSchemaInput, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn> & {
        caseSensitive?: boolean | undefined;
        wrapInSuspense?: boolean | undefined;
        component?: import("./route").RouteComponent<any> | undefined;
        errorComponent?: false | import("./route").ErrorRouteComponent | null | undefined;
        notFoundComponent?: import("./route").NotFoundRouteComponent | undefined;
        pendingComponent?: import("./route").RouteComponent<any> | undefined;
        pendingMs?: number | undefined;
        pendingMinMs?: number | undefined;
        staleTime?: number | undefined;
        gcTime?: number | undefined;
        preloadStaleTime?: number | undefined;
        preloadGcTime?: number | undefined;
        preSearchFilters?: import("./route").SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
        postSearchFilters?: import("./route").SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
        onError?: ((err: any) => void) | undefined;
        onEnter?: ((match: import("./Matches").AnyRouteMatch) => void) | undefined;
        onStay?: ((match: import("./Matches").AnyRouteMatch) => void) | undefined;
        onLeave?: ((match: import("./Matches").AnyRouteMatch) => void) | undefined;
        meta?: ((ctx: {
            params: TAllParams;
            loaderData: TLoaderData;
        }) => import("react").DetailedHTMLProps<import("react").MetaHTMLAttributes<HTMLMetaElement>, HTMLMetaElement>[] | Promise<import("react").DetailedHTMLProps<import("react").MetaHTMLAttributes<HTMLMetaElement>, HTMLMetaElement>[]>) | undefined;
        links?: (() => import("react").DetailedHTMLProps<import("react").LinkHTMLAttributes<HTMLLinkElement>, HTMLLinkElement>[]) | undefined;
        scripts?: (() => import("react").DetailedHTMLProps<import("react").ScriptHTMLAttributes<HTMLScriptElement>, HTMLScriptElement>[]) | undefined;
        headers?: ((ctx: {
            loaderData: TLoaderData;
        }) => Record<string, string> | Promise<Record<string, string>>) | undefined;
    } & {
        staticData?: import("./route").StaticDataRouteOption | undefined;
    }) | undefined) => Route<TParentRoute, TPath, TFullPath, TFilePath, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren, TRouteTree>;
}
/**
  @deprecated It's recommended not to split loaders into separate files.
  Instead, place the loader function in the the main route file, inside the
  `createFileRoute('/path/to/file)(options)` options.
*/
export declare function FileRouteLoader<TFilePath extends keyof FileRoutesByPath, TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute']>(_path: TFilePath): <TLoaderData extends any>(loaderFn: RouteLoaderFn<TRoute['types']['allParams'], TRoute['types']['loaderDeps'], TRoute['types']['allContext'], TRoute['types']['routeContext'], TLoaderData>) => RouteLoaderFn<TRoute['types']['allParams'], TRoute['types']['loaderDeps'], TRoute['types']['allContext'], TRoute['types']['routeContext'], NoInfer<TLoaderData>>;
export type LazyRouteOptions = Pick<UpdatableRouteOptions<AnyPathParams, AnySearchSchema, any>, 'component' | 'errorComponent' | 'pendingComponent' | 'notFoundComponent'>;
export declare class LazyRoute<TRoute extends AnyRoute> {
    options: {
        id: string;
    } & LazyRouteOptions;
    constructor(opts: {
        id: string;
    } & LazyRouteOptions);
    useMatch: <TRouteMatchState = RouteMatch<TRoute["types"]["routeTree"], TRoute["types"]["id"], false>, TSelected = TRouteMatchState>(opts?: {
        select?: ((match: TRouteMatchState) => TSelected) | undefined;
    } | undefined) => TSelected;
    useRouteContext: <TSelected = TRoute["types"]["allContext"]>(opts?: {
        select?: ((s: TRoute['types']['allContext']) => TSelected) | undefined;
    } | undefined) => TSelected;
    useSearch: <TSelected = TRoute["types"]["fullSearchSchema"]>(opts?: {
        select?: ((s: TRoute['types']['fullSearchSchema']) => TSelected) | undefined;
    } | undefined) => TSelected;
    useParams: <TSelected = TRoute["types"]["allParams"]>(opts?: {
        select?: ((s: TRoute['types']['allParams']) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderDeps: <TSelected = TRoute["types"]["loaderDeps"]>(opts?: {
        select?: ((s: TRoute['types']['loaderDeps']) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderData: <TSelected = TRoute["types"]["loaderData"]>(opts?: {
        select?: ((s: TRoute['types']['loaderData']) => TSelected) | undefined;
    } | undefined) => TSelected;
}
export declare function createLazyRoute<TId extends RouteIds<RegisteredRouter['routeTree']>, TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>>(id: TId): (opts: LazyRouteOptions) => LazyRoute<TRoute>;
export declare function createLazyFileRoute<TFilePath extends keyof FileRoutesByPath, TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute']>(path: TFilePath): (opts: LazyRouteOptions) => LazyRoute<TRoute>;
export {};
