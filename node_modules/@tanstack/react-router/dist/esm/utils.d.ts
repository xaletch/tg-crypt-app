import * as React from 'react';
export type NoInfer<T> = [T][T extends any ? 0 : never];
export type IsAny<T, Y, N = T> = 1 extends 0 & T ? Y : N;
export type PickAsRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export type PickRequired<T> = {
    [K in keyof T as undefined extends T[K] ? never : K]: T[K];
};
export type WithoutEmpty<T> = T extends T ? ({} extends T ? never : T) : never;
export type Expand<T> = T extends object ? T extends infer O ? {
    [K in keyof O]: O[K];
} : never : T;
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => any ? I : never;
export type DeepOptional<T, K extends keyof T> = Pick<DeepPartial<T>, K> & Omit<T, K>;
export type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
export type MakeDifferenceOptional<T, U> = Omit<U, keyof T> & Partial<Pick<U, keyof T & keyof U>> & PickRequired<Omit<U, keyof PickRequired<T>>>;
export type IsUnion<T, U extends T = T> = (T extends any ? (U extends T ? false : true) : never) extends false ? false : true;
export type Assign<Left, Right> = Omit<Left, keyof Right> & Right;
export type AssignAll<T extends any[]> = T extends [infer Left, ...infer Right] ? Right extends any[] ? Assign<Left, AssignAll<Right>> : Left : {};
export type Timeout = ReturnType<typeof setTimeout>;
export type Updater<TPrevious, TResult = TPrevious> = TResult | ((prev?: TPrevious) => TResult);
export type NonNullableUpdater<TPrevious, TResult = TPrevious> = TResult | ((prev: TPrevious) => TResult);
type LastInUnion<U> = UnionToIntersection<U extends unknown ? (x: U) => 0 : never> extends (x: infer L) => 0 ? L : never;
export type UnionToTuple<U, Last = LastInUnion<U>> = [U] extends [never] ? [] : [...UnionToTuple<Exclude<U, Last>>, Last];
export declare const isServer: boolean;
export declare function last<T>(arr: T[]): T | undefined;
export declare function functionalUpdate<TResult>(updater: Updater<TResult> | NonNullableUpdater<TResult>, previous: TResult): TResult;
export declare function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K>;
/**
 * This function returns `prev` if `_next` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between immutable JSON values for example.
 * Do not use this with signals
 */
export declare function replaceEqualDeep<T>(prev: any, _next: T): T;
export declare function isPlainObject(o: any): boolean;
export declare function isPlainArray(value: unknown): boolean;
export declare function deepEqual(a: any, b: any, partial?: boolean): boolean;
export declare function useStableCallback<T extends (...args: any[]) => any>(fn: T): T;
export declare function shallow<T>(objA: T, objB: T): boolean;
export type StringLiteral<T> = T extends string ? string extends T ? string : T : never;
export type StrictOrFrom<TFrom, TReturnIntersection extends boolean = false> = {
    from: StringLiteral<TFrom> | TFrom;
    strict?: true;
} | {
    from?: never;
    strict: false;
    experimental_returnIntersection?: TReturnIntersection;
};
export declare const useLayoutEffect: typeof React.useLayoutEffect;
/**
 *
 * @deprecated use `jsesc` instead
 */
export declare function escapeJSON(jsonString: string): string;
export {};
