{"version":3,"file":"awaited.js","sources":["../../src/awaited.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useRouter } from './useRouter'\nimport { defaultSerializeError } from './router'\nimport { DeferredPromise, isDehydratedDeferred } from './defer'\nimport { defaultDeserializeError, isServerSideError } from './Matches'\n\nimport warning from 'tiny-warning'\n\nexport type AwaitOptions<T> = {\n  promise: DeferredPromise<T>\n}\n\nexport function useAwaited<T>({ promise }: AwaitOptions<T>): [T] {\n  const router = useRouter()\n  // const rerender = React.useReducer((x) => x + 1, 0)[1]\n\n  const state = promise.__deferredState\n\n  // Dehydrated promises only\n  // Successful or errored deferred promises mean they\n  // were resolved on the server and no further action is needed\n  if (isDehydratedDeferred(promise) && state.status === 'pending') {\n    const streamedData = (window as any)[`__TSR__DEFERRED__${state.uid}`]\n\n    if (streamedData) {\n      Object.assign(state, router.options.transformer.parse(streamedData))\n    } else {\n      let token = router.registeredDeferredsIds.get(state.uid)\n\n      // If we haven't yet, create a promise and resolver that our streamed HTML can use\n      // when the client-side data is streamed in and ready.\n      if (!token) {\n        token = {}\n        router.registeredDeferredsIds.set(state.uid, token)\n        router.registeredDeferreds.set(token, state)\n\n        Object.assign(state, {\n          resolve: () => {\n            state.__resolvePromise?.()\n            // rerender()\n          },\n          promise: new Promise((r) => {\n            state.__resolvePromise = r as any\n          }),\n          __resolvePromise: () => {},\n        })\n      }\n    }\n  }\n\n  // If the promise is pending, always throw the state.promise\n  // For originating promises, this will be the original promise\n  // For dehydrated promises, this will be the placeholder promise\n  // that will be resolved when the server sends the real data\n  if (state.status === 'pending') {\n    throw isDehydratedDeferred(promise) ? state.promise : promise\n  }\n\n  // If we are the originator of the promise,\n  // inject the state into the HTML stream\n  if (!isDehydratedDeferred(promise)) {\n    router.injectHtml(`<script class='tsr_deferred_data'>window.__TSR__DEFERRED__${state.uid} = ${JSON.stringify(router.options.transformer.stringify(state))}</script>\n<script class='tsr_deferred_handler'>\n  if (window.__TSR__ROUTER__) {\n    let deferred = window.__TSR__ROUTER__.getDeferred('${state.uid}')\n    if (deferred) deferred.resolve(window.__TSR__DEFERRED__${state.uid})\n  }\n  document.querySelectorAll('.tsr_deferred_handler').forEach((el) => el.parentElement.removeChild(el))\n</script>`)\n  }\n\n  if (state.status === 'error') {\n    if (typeof document !== 'undefined') {\n      if (isServerSideError(state.error)) {\n        throw (\n          router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n        )(state.error.data as any)\n      } else {\n        warning(\n          false,\n          \"Encountered a server-side error that doesn't fit the expected shape\",\n        )\n        throw state.error\n      }\n    } else {\n      throw {\n        data: (\n          router.options.errorSerializer?.serialize ?? defaultSerializeError\n        )(state.error),\n        __isServerError: true,\n      }\n    }\n  }\n\n  return [promise.__deferredState.data as any]\n}\n\nexport function Await<T>(\n  props: AwaitOptions<T> & {\n    fallback?: React.ReactNode\n    children: (result: T) => React.ReactNode\n  },\n) {\n  const inner = <AwaitInner {...props} />\n  if (props.fallback) {\n    return <React.Suspense fallback={props.fallback}>{inner}</React.Suspense>\n  }\n  return inner\n}\n\nfunction AwaitInner<T>(\n  props: AwaitOptions<T> & {\n    fallback?: React.ReactNode\n    children: (result: T) => React.ReactNode\n  },\n) {\n  const awaited = useAwaited(props)\n  return props.children(...awaited)\n}\n"],"names":["_a"],"mappings":";;;;;;;AAYgB,SAAA,WAAc,EAAE,WAAiC;;AAC/D,QAAM,SAAS;AAGf,QAAM,QAAQ,QAAQ;AAKtB,MAAI,qBAAqB,OAAO,KAAK,MAAM,WAAW,WAAW;AAC/D,UAAM,eAAgB,OAAe,oBAAoB,MAAM,GAAG,EAAE;AAEpE,QAAI,cAAc;AAChB,aAAO,OAAO,OAAO,OAAO,QAAQ,YAAY,MAAM,YAAY,CAAC;AAAA,IAAA,OAC9D;AACL,UAAI,QAAQ,OAAO,uBAAuB,IAAI,MAAM,GAAG;AAIvD,UAAI,CAAC,OAAO;AACV,gBAAQ,CAAA;AACR,eAAO,uBAAuB,IAAI,MAAM,KAAK,KAAK;AAC3C,eAAA,oBAAoB,IAAI,OAAO,KAAK;AAE3C,eAAO,OAAO,OAAO;AAAA,UACnB,SAAS,MAAM;;AACb,aAAAA,MAAA,MAAM,qBAAN,gBAAAA,IAAA;AAAA,UAEF;AAAA,UACA,SAAS,IAAI,QAAQ,CAAC,MAAM;AAC1B,kBAAM,mBAAmB;AAAA,UAAA,CAC1B;AAAA,UACD,kBAAkB,MAAM;AAAA,UAAC;AAAA,QAAA,CAC1B;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAMI,MAAA,MAAM,WAAW,WAAW;AAC9B,UAAM,qBAAqB,OAAO,IAAI,MAAM,UAAU;AAAA,EACxD;AAII,MAAA,CAAC,qBAAqB,OAAO,GAAG;AAClC,WAAO,WAAW,6DAA6D,MAAM,GAAG,MAAM,KAAK,UAAU,OAAO,QAAQ,YAAY,UAAU,KAAK,CAAC,CAAC;AAAA;AAAA;AAAA,yDAGpG,MAAM,GAAG;AAAA,6DACL,MAAM,GAAG;AAAA;AAAA;AAAA,WAG5D;AAAA,EACR;AAEI,MAAA,MAAM,WAAW,SAAS;AACxB,QAAA,OAAO,aAAa,aAAa;AAC/B,UAAA,kBAAkB,MAAM,KAAK,GAAG;AAClC,iBACE,YAAO,QAAQ,oBAAf,mBAAgC,gBAAe,yBAC/C,MAAM,MAAM,IAAW;AAAA,MAAA,OACpB;AACL;AAAA,UACE;AAAA,UACA;AAAA,QAAA;AAEF,cAAM,MAAM;AAAA,MACd;AAAA,IAAA,OACK;AACC,YAAA;AAAA,QACJ,SACE,YAAO,QAAQ,oBAAf,mBAAgC,cAAa,uBAC7C,MAAM,KAAK;AAAA,QACb,iBAAiB;AAAA,MAAA;AAAA,IAErB;AAAA,EACF;AAEO,SAAA,CAAC,QAAQ,gBAAgB,IAAW;AAC7C;AAEO,SAAS,MACd,OAIA;AACA,QAAM,QAAQ,oBAAC,YAAY,EAAA,GAAG,MAAO,CAAA;AACrC,MAAI,MAAM,UAAU;AAClB,+BAAQ,MAAM,UAAN,EAAe,UAAU,MAAM,UAAW,UAAM,MAAA,CAAA;AAAA,EAC1D;AACO,SAAA;AACT;AAEA,SAAS,WACP,OAIA;AACM,QAAA,UAAU,WAAW,KAAK;AACzB,SAAA,MAAM,SAAS,GAAG,OAAO;AAClC;"}