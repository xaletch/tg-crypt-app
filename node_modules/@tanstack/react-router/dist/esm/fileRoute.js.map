{"version":3,"file":"fileRoute.js","sources":["../../src/fileRoute.ts"],"sourcesContent":["import { NoInfer } from '@tanstack/react-store'\nimport { ParsePathParams } from './link'\nimport {\n  AnyRoute,\n  ResolveFullPath,\n  ResolveFullSearchSchema,\n  MergeFromFromParent,\n  RouteContext,\n  AnyContext,\n  RouteOptions,\n  UpdatableRouteOptions,\n  Route,\n  createRoute,\n  RootRouteId,\n  TrimPathLeft,\n  RouteConstraints,\n  ResolveFullSearchSchemaInput,\n  SearchSchemaInput,\n  RouteLoaderFn,\n  AnyPathParams,\n  AnySearchSchema,\n  FileBaseRouteOptions,\n} from './route'\nimport { Assign, Expand, IsAny } from './utils'\nimport { useMatch, useLoaderDeps, useLoaderData, RouteMatch } from './Matches'\nimport { useSearch } from './useSearch'\nimport { useParams } from './useParams'\nimport warning from 'tiny-warning'\nimport { RegisteredRouter } from './router'\nimport { RouteById, RouteIds } from './routeInfo'\n\nexport interface FileRoutesByPath {\n  // '/': {\n  //   parentRoute: typeof rootRoute\n  // }\n}\n\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string,\n> = S extends `${infer Start}${From}${infer Rest}`\n  ? `${Start}${To}${Replace<Rest, From, To>}`\n  : S\n\nexport type TrimLeft<\n  T extends string,\n  S extends string,\n> = T extends `${S}${infer U}` ? U : T\n\nexport type TrimRight<\n  T extends string,\n  S extends string,\n> = T extends `${infer U}${S}` ? U : T\n\nexport type Trim<T extends string, S extends string> = TrimLeft<\n  TrimRight<T, S>,\n  S\n>\n\nexport type RemoveUnderScores<T extends string> = Replace<\n  Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>,\n  '/_',\n  '/'\n>\n\ntype RemoveRouteGroups<S extends string> =\n  S extends `${infer Before}(${infer RouteGroup})${infer After}`\n    ? RemoveRouteGroups<`${Before}${After}`>\n    : S\n\ntype NormalizeSlashes<S extends string> =\n  S extends `${infer Before}//${infer After}`\n    ? NormalizeSlashes<`${Before}/${After}`>\n    : S\n\ntype ReplaceFirstOccurrence<\n  T extends string,\n  Search extends string,\n  Replacement extends string,\n> = T extends `${infer Prefix}${Search}${infer Suffix}`\n  ? `${Prefix}${Replacement}${Suffix}`\n  : T\n\nexport type ResolveFilePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = TParentRoute['id'] extends RootRouteId\n  ? TrimPathLeft<TFilePath>\n  : ReplaceFirstOccurrence<\n      TrimPathLeft<TFilePath>,\n      TrimPathLeft<TParentRoute['types']['customId']>,\n      ''\n    >\n\nexport type FileRoutePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> =\n  ResolveFilePath<TParentRoute, TFilePath> extends `_${infer _}`\n    ? ''\n    : ResolveFilePath<TParentRoute, TFilePath> extends `/_${infer _}`\n      ? ''\n      : ResolveFilePath<TParentRoute, TFilePath>\n\nexport function createFileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = NormalizeSlashes<\n    RemoveRouteGroups<TFilePath>\n  >,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    NormalizeSlashes<RemoveRouteGroups<RemoveUnderScores<TPath>>>\n  >,\n>(path: TFilePath) {\n  return new FileRoute<TFilePath, TParentRoute, TId, TPath, TFullPath>(path, {\n    silent: true,\n  }).createRoute\n}\n\n/** \n  @deprecated It's no longer recommended to use the `FileRoute` class directly.\n  Instead, use `createFileRoute('/path/to/file')(options)` to create a file route.\n*/\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = TFilePath,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    RemoveUnderScores<TPath>\n  >,\n> {\n  silent?: boolean\n\n  constructor(\n    public path: TFilePath,\n    _opts?: { silent: boolean },\n  ) {\n    this.silent = _opts?.silent\n  }\n\n  createRoute = <\n    TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {},\n    TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n    TSearchSchemaUsed extends Record<\n      string,\n      any\n    > = TSearchSchemaInput extends SearchSchemaInput\n      ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n      : TSearchSchema,\n    TFullSearchSchemaInput extends\n      RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchemaInput<\n      TParentRoute,\n      TSearchSchemaUsed\n    >,\n    TFullSearchSchema extends\n      RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n      TParentRoute,\n      TSearchSchema\n    >,\n    TParams extends RouteConstraints['TParams'] = Expand<\n      Record<ParsePathParams<TPath>, string>\n    >,\n    TAllParams extends RouteConstraints['TAllParams'] = MergeFromFromParent<\n      TParentRoute['types']['allParams'],\n      TParams\n    >,\n    TRouteContextReturn extends\n      RouteConstraints['TRouteContext'] = RouteContext,\n    TRouteContext extends RouteConstraints['TRouteContext'] = [\n      TRouteContextReturn,\n    ] extends [never]\n      ? RouteContext\n      : TRouteContextReturn,\n    TAllContext extends Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    > = Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    >,\n    TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderDataReturn extends any = unknown,\n    TLoaderData extends any = [TLoaderDataReturn] extends [never]\n      ? undefined\n      : TLoaderDataReturn,\n    TChildren extends RouteConstraints['TChildren'] = unknown,\n    TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n  >(\n    options?: FileBaseRouteOptions<\n      TParentRoute,\n      TPath,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderDataReturn\n    > &\n      UpdatableRouteOptions<TAllParams, TFullSearchSchema, TLoaderData>,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TChildren,\n    TRouteTree\n  > => {\n    warning(\n      this.silent,\n      'FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead.',\n    )\n    const route = createRoute(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n\n/** \n  @deprecated It's recommended not to split loaders into separate files.\n  Instead, place the loader function in the the main route file, inside the\n  `createFileRoute('/path/to/file)(options)` options.\n*/\nexport function FileRouteLoader<\n  TFilePath extends keyof FileRoutesByPath,\n  TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute'],\n>(\n  _path: TFilePath,\n): <TLoaderData extends any>(\n  loaderFn: RouteLoaderFn<\n    TRoute['types']['allParams'],\n    TRoute['types']['loaderDeps'],\n    TRoute['types']['allContext'],\n    TRoute['types']['routeContext'],\n    TLoaderData\n  >,\n) => RouteLoaderFn<\n  TRoute['types']['allParams'],\n  TRoute['types']['loaderDeps'],\n  TRoute['types']['allContext'],\n  TRoute['types']['routeContext'],\n  NoInfer<TLoaderData>\n> {\n  warning(\n    false,\n    `FileRouteLoader is deprecated and will be removed in the next major version. Please place the loader function in the the main route file, inside the \\`createFileRoute('/path/to/file')(options)\\` options`,\n  )\n  return (loaderFn) => loaderFn\n}\n\nexport type LazyRouteOptions = Pick<\n  UpdatableRouteOptions<AnyPathParams, AnySearchSchema, any>,\n  'component' | 'errorComponent' | 'pendingComponent' | 'notFoundComponent'\n>\n\nexport class LazyRoute<TRoute extends AnyRoute> {\n  options: {\n    id: string\n  } & LazyRouteOptions\n\n  constructor(\n    opts: {\n      id: string\n    } & LazyRouteOptions,\n  ) {\n    this.options = opts\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  useMatch = <\n    TRouteMatchState = RouteMatch<\n      TRoute['types']['routeTree'],\n      TRoute['types']['id']\n    >,\n    TSelected = TRouteMatchState,\n  >(opts?: {\n    select?: (match: TRouteMatchState) => TSelected\n  }): TSelected => {\n    return useMatch({ select: opts?.select, from: this.options.id })\n  }\n\n  useRouteContext = <TSelected = TRoute['types']['allContext']>(opts?: {\n    select?: (s: TRoute['types']['allContext']) => TSelected\n  }): TSelected => {\n    return useMatch({\n      from: this.options.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = TRoute['types']['fullSearchSchema']>(opts?: {\n    select?: (s: TRoute['types']['fullSearchSchema']) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.options.id })\n  }\n\n  useParams = <TSelected = TRoute['types']['allParams']>(opts?: {\n    select?: (s: TRoute['types']['allParams']) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.options.id })\n  }\n\n  useLoaderDeps = <TSelected = TRoute['types']['loaderDeps']>(opts?: {\n    select?: (s: TRoute['types']['loaderDeps']) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.options.id } as any)\n  }\n\n  useLoaderData = <TSelected = TRoute['types']['loaderData']>(opts?: {\n    select?: (s: TRoute['types']['loaderData']) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.options.id } as any)\n  }\n}\n\nexport function createLazyRoute<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n>(id: TId) {\n  return (opts: LazyRouteOptions) => {\n    return new LazyRoute<TRoute>({ id: id as any, ...opts })\n  }\n}\n\nexport function createLazyFileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute'],\n>(path: TFilePath) {\n  const id = removeGroups(path)\n  return (opts: LazyRouteOptions) => new LazyRoute<TRoute>({ id, ...opts })\n}\n\nconst routeGroupPatternRegex = /\\(.+\\)/g\n\nfunction removeGroups(s: string) {\n  return s.replaceAll(routeGroupPatternRegex, '').replaceAll('//', '/')\n}\n"],"names":["opts"],"mappings":";;;;;AAyGO,SAAS,gBAcd,MAAiB;AACV,SAAA,IAAI,UAA0D,MAAM;AAAA,IACzE,QAAQ;AAAA,EACT,CAAA,EAAE;AACL;AAMO,MAAM,UAYX;AAAA,EAGA,YACS,MACP,OACA;AAFO,SAAA,OAAA;AAMT,SAAA,cAAc,CA+CZ,YAsCG;AACH;AAAA,QACE,KAAK;AAAA,QACL;AAAA,MAAA;AAEI,YAAA,QAAQ,YAAY,OAAc;AACtC,YAAc,SAAS;AAClB,aAAA;AAAA,IAAA;AA/FP,SAAK,SAAS,+BAAO;AAAA,EACvB;AAgGF;AAOO,SAAS,gBAId,OAeA;AACA;AAAA,IACE;AAAA,IACA;AAAA,EAAA;AAEF,SAAO,CAAC,aAAa;AACvB;AAOO,MAAM,UAAmC;AAAA,EAK9C,YACE,MAGA;AAKF,SAAA,WAAW,CAMTA,UAEe;AACR,aAAA,SAAS,EAAE,QAAQA,SAAA,gBAAAA,MAAM,QAAQ,MAAM,KAAK,QAAQ,GAAA,CAAI;AAAA,IAAA;AAGjE,SAAA,kBAAkB,CAA4CA,UAE7C;AACf,aAAO,SAAS;AAAA,QACd,MAAM,KAAK,QAAQ;AAAA,QACnB,QAAQ,CAAC,OAAYA,SAAA,gBAAAA,MAAM,UAASA,MAAK,OAAO,EAAE,OAAO,IAAI,EAAE;AAAA,MAAA,CAChE;AAAA,IAAA;AAGH,SAAA,YAAY,CAAkDA,UAE7C;AACR,aAAA,UAAU,EAAE,GAAGA,OAAM,MAAM,KAAK,QAAQ,IAAI;AAAA,IAAA;AAGrD,SAAA,YAAY,CAA2CA,UAEtC;AACR,aAAA,UAAU,EAAE,GAAGA,OAAM,MAAM,KAAK,QAAQ,IAAI;AAAA,IAAA;AAGrD,SAAA,gBAAgB,CAA4CA,UAE3C;AACR,aAAA,cAAc,EAAE,GAAGA,OAAM,MAAM,KAAK,QAAQ,IAAW;AAAA,IAAA;AAGhE,SAAA,gBAAgB,CAA4CA,UAE3C;AACR,aAAA,cAAc,EAAE,GAAGA,OAAM,MAAM,KAAK,QAAQ,IAAW;AAAA,IAAA;AA9C9D,SAAK,UAAU;AACb,SAAa,WAAW,OAAO,IAAI,YAAY;AAAA,EACnD;AA8CF;AAEO,SAAS,gBAGd,IAAS;AACT,SAAO,CAAC,SAA2B;AACjC,WAAO,IAAI,UAAkB,EAAE,IAAe,GAAG,KAAM,CAAA;AAAA,EAAA;AAE3D;AAEO,SAAS,oBAGd,MAAiB;AACX,QAAA,KAAK,aAAa,IAAI;AACrB,SAAA,CAAC,SAA2B,IAAI,UAAkB,EAAE,IAAI,GAAG,MAAM;AAC1E;AAEA,MAAM,yBAAyB;AAE/B,SAAS,aAAa,GAAW;AAC/B,SAAO,EAAE,WAAW,wBAAwB,EAAE,EAAE,WAAW,MAAM,GAAG;AACtE;"}