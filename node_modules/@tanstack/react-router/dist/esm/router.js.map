{"version":3,"file":"router.js","sources":["../../src/router.ts"],"sourcesContent":["import * as React from 'react'\nimport {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n} from '@tanstack/history'\nimport { Store } from '@tanstack/react-store'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  RouteMask,\n  Route,\n  LoaderFnContext,\n  rootRouteId,\n  NotFoundRouteComponent,\n} from './route'\nimport {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  PickAsRequired,\n  Updater,\n  NonNullableUpdater,\n  replaceEqualDeep,\n  deepEqual,\n  escapeJSON,\n  functionalUpdate,\n  last,\n  pick,\n  Timeout,\n  isServer,\n} from './utils'\nimport { RouteComponent } from './route'\nimport { AnyRouteMatch, MatchRouteOptions, RouteMatch } from './Matches'\nimport { ParsedLocation } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport {\n  BuildLocationFn,\n  CommitLocationOptions,\n  InjectedHtmlEntry,\n  NavigateFn,\n  getRouteMatch,\n} from './RouterProvider'\n\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport invariant from 'tiny-invariant'\nimport { AnyRedirect, ResolvedRedirect, isRedirect } from './redirects'\nimport { NotFoundError, isNotFound } from './not-found'\nimport { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport { NoInfer } from '@tanstack/react-store'\nimport warning from 'tiny-warning'\nimport { DeferredPromiseState } from './defer'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: { data: string }\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<AnyRoute, any, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: RouteComponent\n  defaultPendingComponent?: RouteComponent\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultStaleTime?: number\n  defaultPreloadStaleTime?: number\n  defaultPreloadGcTime?: number\n  notFoundMode?: 'root' | 'fuzzy'\n  defaultGcTime?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  context?: TRouteTree['types']['routerContext']\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n  Wrap?: (props: { children: any }) => React.ReactNode\n  InnerWrap?: (props: { children: any }) => React.ReactNode\n  /**\n   * @deprecated\n   * Use `notFoundComponent` instead.\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   */\n  notFoundRoute?: AnyRoute\n  defaultNotFoundComponent?: NotFoundRouteComponent\n  transformer?: RouterTransformer\n  errorSerializer?: RouterErrorSerializer<TSerializedError>\n}\n\nexport interface RouterTransformer {\n  stringify: (obj: unknown) => string\n  parse: (str: string) => unknown\n}\nexport interface RouterErrorSerializer<TSerializedError> {\n  serialize: (err: unknown) => TSerializedError\n  deserialize: (err: TSerializedError) => unknown\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches?: RouteMatch<TRouteTree>[]\n  cachedMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n  statusCode: number\n  redirect?: ResolvedRedirect\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'id' | 'status' | 'updatedAt' | 'loaderData'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n  TSerializedError extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated, TSerializedError>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n  'notFoundComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport function createRouter<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n>(\n  options: RouterConstructorOptions<TRouteTree, TDehydrated, TSerializedError>,\n) {\n  return new Router<TRouteTree, TDehydrated, TSerializedError>(options)\n}\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll: boolean = true\n  navigateTimeout: Timeout | null = null\n  latestLoadPromise: Promise<void> = Promise.resolve()\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  injectedHtml: InjectedHtmlEntry[] = []\n  dehydratedData?: TDehydrated\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    Omit<\n      RouterOptions<TRouteTree, TDehydrated, TSerializedError>,\n      'transformer'\n    > & {\n      transformer: RouterTransformer\n    },\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: AnyRoute[]\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TDehydrated,\n      TSerializedError\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n      transformer: options?.transformer ?? JSON,\n    })\n\n    if (typeof document !== 'undefined') {\n      ;(window as any).__TSR__ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n\n  update = (\n    newOptions: RouterConstructorOptions<\n      TRouteTree,\n      TDehydrated,\n      TSerializedError\n    >,\n  ) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const previousOptions = this.options\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    if (\n      !this.basepath ||\n      (newOptions.basepath && newOptions.basepath !== previousOptions.basepath)\n    ) {\n      if (\n        newOptions.basepath === undefined ||\n        newOptions.basepath === '' ||\n        newOptions.basepath === '/'\n      ) {\n        this.basepath = '/'\n      } else {\n        this.basepath = `/${trimPath(newOptions.basepath)}`\n      }\n    }\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (typeof document !== 'undefined'\n          ? createBrowserHistory()\n          : createMemoryHistory({\n              initialEntries: [this.options.basepath || '/'],\n            }))\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            status:\n              this.state.isTransitioning || this.state.isLoading\n                ? 'pending'\n                : 'idle',\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({ originalIndex: 99999999999 })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: AnyRoute[]) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: {\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: number[]\n    }[] = []\n\n    ;(Object.values(this.routesById) as AnyRoute[]).forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((d) => {\n        if (d.value === '/') {\n          return 0.75\n        }\n\n        if (d.type === 'param') {\n          return 0.5\n        }\n\n        if (d.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return this.latestLoadPromise !== promise\n      ? this.latestLoadPromise\n      : undefined\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n\n      return {\n        pathname: pathname,\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${searchStr}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state) as HistoryState,\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    let { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes = <TRouteTree extends AnyRoute>(\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { preload?: boolean; throwOnError?: boolean; debug?: boolean },\n  ): RouteMatch<TRouteTree>[] => {\n    let routeParams: Record<string, string> = {}\n\n    let foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)[rootRouteId]\n\n    let matchedRoutes: AnyRoute[] = [routeCursor]\n\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      if (routeCursor) matchedRoutes.unshift(routeCursor)\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: AnyRouteMatch[] = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n      const isLast = index === matchedRoutes.length - 1\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          let search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchError\n          }\n\n          return [parentSearch, searchError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const interpolatedPath = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n      })\n\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n        }) + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      let existingMatch = getRouteMatch(this.state, matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      const match: AnyRouteMatch = existingMatch\n        ? {\n            ...existingMatch,\n            cause,\n            params: routeParams,\n          }\n        : {\n            id: matchId,\n            routeId: route.id,\n            params: routeParams,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n            updatedAt: Date.now(),\n            search: {} as any,\n            searchError: undefined,\n            status: 'pending',\n            showPending: false,\n            isFetching: false,\n            error: undefined,\n            paramsError: parseErrors[index],\n            loadPromise: Promise.resolve(),\n            routeContext: undefined!,\n            context: undefined!,\n            abortController: new AbortController(),\n            fetchCount: 0,\n            cause,\n            loaderDeps,\n            invalid: false,\n            preload: false,\n            links: route.options.links?.(),\n            scripts: route.options.scripts?.(),\n            staticData: route.options.staticData || {},\n          }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    getRouteMatch(this.state, id)?.abortController.abort()\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn<TRouteTree> = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: AnyRouteMatch[],\n    ): ParsedLocation => {\n      // if (dest.href) {\n      //   return {\n      //     pathname: dest.href,\n      //     search: {},\n      //     searchStr: '',\n      //     state: {},\n      //     hash: '',\n      //     href: dest.href,\n      //     unmaskOnReload: dest.unmaskOnReload,\n      //   }\n      // }\n\n      const relevantMatches = this.state.pendingMatches || this.state.matches\n      const fromSearch =\n        relevantMatches[relevantMatches.length - 1]?.search ||\n        this.latestLocation.search\n\n      const fromMatches = this.matchRoutes(\n        this.latestLocation.pathname,\n        fromSearch,\n      )\n      const stayingMatches = matches?.filter((d) =>\n        fromMatches?.find((e) => e.routeId === d.routeId),\n      )\n\n      const fromRoute = this.looseRoutesById[last(fromMatches)?.routeId]\n\n      let pathname = dest.to\n        ? this.resolvePathWithBase(\n            dest.from ?? this.latestLocation.pathname,\n            `${dest.to}`,\n          )\n        : this.resolvePathWithBase(fromRoute?.fullPath, fromRoute?.fullPath)\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : { ...prevParams, ...functionalUpdate(dest.params!, prevParams) }\n\n      if (Object.keys(nextParams).length > 0) {\n        matches\n          ?.map((d) => this.looseRoutesById[d.routeId]!.options.stringifyParams)\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams!) }\n          })\n      }\n\n      pathname = interpolatePath({\n        path: pathname,\n        params: nextParams ?? {},\n        leaveWildcards: false,\n        leaveParams: opts.leaveParams,\n      })\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters?.length\n        ? preSearchFilters?.reduce(\n            (prev, next) => next(prev) as any,\n            fromSearch,\n          )\n        : fromSearch\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters?.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? this.latestLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash!, this.latestLocation.hash)\n            : undefined\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? this.latestLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, this.latestLocation.state)\n            : {}\n\n      nextState = replaceEqualDeep(this.latestLocation.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      let next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        let foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          maskedDest = {\n            ...pick(opts, ['from']),\n            ...foundMask,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next.pathname, next.search)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext.pathname, maskedNext.search)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocation = async ({\n    startTransition,\n    ...next\n  }: ParsedLocation & CommitLocationOptions) => {\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl) {\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      const apply = () => {\n        this.history[next.replace ? 'replace' : 'push'](\n          nextHistory.href,\n          nextHistory.state,\n        )\n      }\n\n      if (startTransition ?? true) {\n        this.startReactTransition(apply)\n      } else {\n        apply()\n      }\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    return this.latestLoadPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const location = this.buildLocation(rest as any)\n    return this.commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll,\n    })\n  }\n\n  navigate: NavigateFn = ({ from, to, ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    // const fromString = from !== undefined ? String(from) : from\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      from,\n      to,\n      // to: toString,\n    })\n  }\n\n  loadMatches = async ({\n    checkLatest,\n    location,\n    matches,\n    preload,\n  }: {\n    checkLatest: () => Promise<void> | undefined\n    location: ParsedLocation\n    matches: AnyRouteMatch[]\n    preload?: boolean\n  }): Promise<RouteMatch[]> => {\n    let latestPromise\n    let firstBadMatchIndex: number | undefined\n\n    const updateMatch = (match: AnyRouteMatch, opts?: { remove?: boolean }) => {\n      const isPending = this.state.pendingMatches?.find(\n        (d) => d.id === match.id,\n      )\n\n      const isMatched = this.state.matches.find((d) => d.id === match.id)\n\n      const matchesKey = isPending\n        ? 'pendingMatches'\n        : isMatched\n          ? 'matches'\n          : 'cachedMatches'\n\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: opts?.remove\n          ? s[matchesKey]?.filter((d) => d.id !== match.id)\n          : s[matchesKey]?.map((d) => (d.id === match.id ? match : d)),\n      }))\n    }\n\n    const handleMatchSpecialError = (match: AnyRouteMatch, err: any) => {\n      match = {\n        ...match,\n        status: isRedirect(err)\n          ? 'redirected'\n          : isNotFound(err)\n            ? 'notFound'\n            : 'error',\n        isFetching: false,\n        error: err,\n      }\n\n      updateMatch(match)\n\n      if (!err.routeId) {\n        err.routeId = match.routeId\n      }\n\n      throw err\n    }\n\n    // Check each match middleware to see if the route can be accessed\n    for (let [index, match] of matches.entries()) {\n      const parentMatch = matches[index - 1]\n      const route = this.looseRoutesById[match.routeId]!\n      const abortController = new AbortController()\n\n      const handleSerialError = (err: any, code: string) => {\n        err.routerCode = code\n        firstBadMatchIndex = firstBadMatchIndex ?? index\n\n        if (isRedirect(err) || isNotFound(err)) {\n          handleMatchSpecialError(match, err)\n        }\n\n        try {\n          route.options.onError?.(err)\n        } catch (errorHandlerErr) {\n          err = errorHandlerErr\n\n          if (isRedirect(err) || isNotFound(err)) {\n            handleMatchSpecialError(match, errorHandlerErr)\n          }\n        }\n\n        matches[index] = match = {\n          ...match,\n          error: err,\n          status: 'error',\n          updatedAt: Date.now(),\n          abortController: new AbortController(),\n        }\n      }\n\n      if (match.paramsError) {\n        handleSerialError(match.paramsError, 'PARSE_PARAMS')\n      }\n\n      if (match.searchError) {\n        handleSerialError(match.searchError, 'VALIDATE_SEARCH')\n      }\n\n      // if (match.globalNotFound && !preload) {\n      //   handleSerialError(notFound({ _global: true }), 'NOT_FOUND')\n      // }\n\n      try {\n        const parentContext = parentMatch?.context ?? this.options.context ?? {}\n\n        const pendingMs =\n          route.options.pendingMs ?? this.options.defaultPendingMs\n        const pendingPromise =\n          typeof pendingMs === 'number' && pendingMs <= 0\n            ? Promise.resolve()\n            : new Promise<void>((r) => setTimeout(r, pendingMs))\n\n        const beforeLoadContext =\n          (await route.options.beforeLoad?.({\n            search: match.search,\n            abortController,\n            params: match.params,\n            preload: !!preload,\n            context: parentContext,\n            location,\n            navigate: (opts) =>\n              this.navigate({ ...opts, from: match.pathname } as any),\n            buildLocation: this.buildLocation,\n            cause: preload ? 'preload' : match.cause,\n          })) ?? ({} as any)\n\n        if (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) {\n          handleSerialError(beforeLoadContext, 'BEFORE_LOAD')\n        }\n\n        const context = {\n          ...parentContext,\n          ...beforeLoadContext,\n        }\n\n        matches[index] = match = {\n          ...match,\n          routeContext: replaceEqualDeep(match.routeContext, beforeLoadContext),\n          context: replaceEqualDeep(match.context, context),\n          abortController,\n          pendingPromise,\n        }\n      } catch (err) {\n        handleSerialError(err, 'BEFORE_LOAD')\n        break\n      }\n    }\n\n    const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n    const matchPromises: Promise<any>[] = []\n\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push(\n        new Promise<void>(async (resolve, reject) => {\n          const parentMatchPromise = matchPromises[index - 1]\n          const route = this.looseRoutesById[match.routeId]!\n\n          const handleError = (err: any) => {\n            if (isRedirect(err) || isNotFound(err)) {\n              handleMatchSpecialError(match, err)\n            }\n          }\n\n          let loadPromise: Promise<void> | undefined\n\n          matches[index] = match = {\n            ...match,\n            showPending: false,\n          }\n\n          let didShowPending = false\n          const pendingMs =\n            route.options.pendingMs ?? this.options.defaultPendingMs\n          const pendingMinMs =\n            route.options.pendingMinMs ?? this.options.defaultPendingMinMs\n\n          const loaderContext: LoaderFnContext = {\n            params: match.params,\n            deps: match.loaderDeps,\n            preload: !!preload,\n            parentMatchPromise,\n            abortController: match.abortController,\n            context: match.context,\n            location,\n            navigate: (opts) =>\n              this.navigate({ ...opts, from: match.pathname } as any),\n            cause: preload ? 'preload' : match.cause,\n            route,\n          }\n\n          const fetch = async () => {\n            try {\n              if (match.isFetching) {\n                loadPromise = getRouteMatch(this.state, match.id)?.loadPromise\n              } else {\n                // If the user doesn't want the route to reload, just\n                // resolve with the existing loader data\n\n                // if (match.fetchCount && match.status === 'success') {\n                //   resolve()\n                // }\n\n                // Otherwise, load the route\n                matches[index] = match = {\n                  ...match,\n                  isFetching: true,\n                  fetchCount: match.fetchCount + 1,\n                }\n\n                const lazyPromise =\n                  route.lazyFn?.().then((lazyRoute) => {\n                    Object.assign(route.options, lazyRoute.options)\n                  }) || Promise.resolve()\n\n                // If for some reason lazy resolves more lazy components...\n                // We'll wait for that before pre attempt to preload any\n                // components themselves.\n                const componentsPromise = lazyPromise.then(() =>\n                  Promise.all(\n                    componentTypes.map(async (type) => {\n                      const component = route.options[type]\n\n                      if ((component as any)?.preload) {\n                        await (component as any).preload()\n                      }\n                    }),\n                  ),\n                )\n\n                // Kick off the loader!\n                const loaderPromise = route.options.loader?.(loaderContext)\n\n                loadPromise = Promise.all([\n                  componentsPromise,\n                  loaderPromise,\n                  lazyPromise,\n                ]).then((d) => d[1])\n              }\n\n              matches[index] = match = {\n                ...match,\n                loadPromise,\n              }\n\n              updateMatch(match)\n\n              const loaderData = await loadPromise\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              handleError(loaderData)\n\n              if (didShowPending && pendingMinMs) {\n                await new Promise((r) => setTimeout(r, pendingMinMs))\n              }\n\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              const [meta, headers] = await Promise.all([\n                route.options.meta?.({\n                  params: match.params,\n                  loaderData,\n                }),\n                route.options.headers?.({\n                  loaderData,\n                }),\n              ])\n\n              matches[index] = match = {\n                ...match,\n                error: undefined,\n                status: 'success',\n                isFetching: false,\n                updatedAt: Date.now(),\n                loaderData,\n                loadPromise: undefined,\n                meta,\n                headers,\n              }\n            } catch (error) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              handleError(error)\n\n              try {\n                route.options.onError?.(error)\n              } catch (onErrorError) {\n                error = onErrorError\n                handleError(onErrorError)\n              }\n\n              matches[index] = match = {\n                ...match,\n                error,\n                status: 'error',\n                isFetching: false,\n              }\n            }\n\n            updateMatch(match)\n          }\n\n          // This is where all of the stale-while-revalidate magic happens\n          const age = Date.now() - match.updatedAt\n\n          let staleAge = preload\n            ? route.options.preloadStaleTime ??\n              this.options.defaultPreloadStaleTime ??\n              30_000 // 30 seconds for preloads by default\n            : route.options.staleTime ?? this.options.defaultStaleTime ?? 0\n\n          // Default to reloading the route all the time\n          let shouldReload\n\n          const shouldReloadOption = route.options.shouldReload\n\n          // Allow shouldReload to get the last say,\n          // if provided.\n          shouldReload =\n            typeof shouldReloadOption === 'function'\n              ? shouldReloadOption(loaderContext)\n              : shouldReloadOption\n\n          matches[index] = match = {\n            ...match,\n            preload:\n              !!preload && !this.state.matches.find((d) => d.id === match.id),\n          }\n\n          // If the route is successful and still fresh, just resolve\n          if (\n            match.status === 'success' &&\n            (match.invalid || (shouldReload ?? age > staleAge))\n          ) {\n            ;(async () => {\n              try {\n                await fetch()\n              } catch (err) {\n                console.info('Background Fetching Error', err)\n\n                if (isRedirect(err)) {\n                  const isActive = (\n                    this.state.pendingMatches || this.state.matches\n                  ).find((d) => d.id === match.id)\n\n                  // Redirects should not be persisted\n                  handleError(err)\n\n                  // If the route is still active, redirect\n                  // TODO: Do we really need this?\n                  invariant(\n                    false,\n                    'You need to redirect from a background fetch? This is not supported yet. File an issue.',\n                  )\n                  // if (isActive) {\n                  //   this.handleRedirect(err)\n                  // }\n                }\n              }\n            })()\n\n            return resolve()\n          }\n\n          const shouldPending =\n            !preload &&\n            typeof pendingMs === 'number' &&\n            (route.options.pendingComponent ??\n              this.options.defaultPendingComponent)\n\n          if (match.status !== 'success') {\n            try {\n              if (shouldPending) {\n                match.pendingPromise?.then(async () => {\n                  if ((latestPromise = checkLatest())) return latestPromise\n\n                  didShowPending = true\n                  matches[index] = match = {\n                    ...match,\n                    showPending: true,\n                  }\n\n                  updateMatch(match)\n                  resolve()\n                })\n              }\n\n              await fetch()\n            } catch (err) {\n              reject(err)\n            }\n          }\n\n          resolve()\n        }),\n      )\n    })\n\n    await Promise.all(matchPromises)\n\n    return matches\n  }\n\n  invalidate = () => {\n    const invalidate = (d: any) => ({\n      ...d,\n      invalid: true,\n    })\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.load()\n  }\n\n  load = async (): Promise<void> => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = this.latestLocation\n      const prevLocation = this.state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      this.cancelMatches()\n\n      this.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      let pendingMatches!: RouteMatch<any, any>[]\n      const previousMatches = this.state.matches\n\n      this.__store.batch(() => {\n        this.cleanCache()\n\n        // Match the routes\n        pendingMatches = this.matchRoutes(next.pathname, next.search, {\n          debug: true,\n        })\n\n        // Ingest the new matches\n        // If a cached moved to pendingMatches, remove it from cachedMatches\n        this.__store.setState((s) => ({\n          ...s,\n          isLoading: true,\n          location: next,\n          pendingMatches,\n          cachedMatches: s.cachedMatches.filter((d) => {\n            return !pendingMatches.find((e) => e.id === d.id)\n          }),\n        }))\n      })\n\n      try {\n        let redirect: ResolvedRedirect\n        let notFound: NotFoundError\n\n        try {\n          // Load the matches\n          await this.loadMatches({\n            matches: pendingMatches,\n            location: next,\n            checkLatest: () => this.checkLatest(promise),\n          })\n        } catch (err) {\n          if (isRedirect(err)) {\n            redirect = this.resolveRedirect(err)\n\n            if (!isServer) {\n              this.navigate({ ...(redirect as any), replace: true })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n            this.handleNotFound(pendingMatches, err)\n          }\n\n          // Swallow all other errors that happen inside\n          // of loadMatches. These errors will be handled\n          // as state on each match.\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatches = previousMatches.filter(\n          (match) => !pendingMatches.find((d) => d.id === match.id),\n        )\n        const enteringMatches = pendingMatches.filter(\n          (match) => !previousMatches.find((d) => d.id === match.id),\n        )\n        const stayingMatches = previousMatches.filter((match) =>\n          pendingMatches.find((d) => d.id === match.id),\n        )\n\n        // Commit the pending matches. If a previous match was\n        // removed, place it in the cachedMatches\n        this.__store.batch(() => {\n          this.__store.setState((s) => ({\n            ...s,\n            isLoading: false,\n            matches: s.pendingMatches!,\n            pendingMatches: undefined,\n            cachedMatches: [\n              ...s.cachedMatches,\n              ...exitingMatches.filter((d) => d.status !== 'error'),\n            ],\n            statusCode:\n              redirect?.statusCode || notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n          this.cleanCache()\n        })\n\n        //\n        ;(\n          [\n            [exitingMatches, 'onLeave'],\n            [enteringMatches, 'onEnter'],\n            [stayingMatches, 'onStay'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        this.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        console.log('Load Error', err)\n\n        reject(err)\n      }\n    })\n\n    this.latestLoadPromise = promise\n\n    return this.latestLoadPromise\n  }\n\n  resolveRedirect = (err: AnyRedirect): ResolvedRedirect => {\n    let redirect = err as ResolvedRedirect\n\n    if (!redirect.href) {\n      redirect.href = this.buildLocation(redirect as any).href\n    }\n\n    return redirect\n  }\n\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter((d) => {\n          const route = this.looseRoutesById[d.routeId]!\n\n          if (!route.options.loader) {\n            return false\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime =\n            (d.preload\n              ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime\n              : route.options.gcTime ?? this.options.defaultGcTime) ??\n            5 * 60 * 1000\n\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime\n        }),\n      }\n    })\n  }\n\n  preloadRoute = async <\n    TFrom extends RoutePaths<TRouteTree> | string = string,\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n    TMaskTo extends string = '',\n  >(\n    opts: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n  ): Promise<AnyRouteMatch[] | undefined> => {\n    let next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n      preload: true,\n    })\n\n    const loadedMatchIds = Object.fromEntries(\n      [\n        ...this.state.matches,\n        ...(this.state.pendingMatches ?? []),\n        ...this.state.cachedMatches,\n      ]?.map((d) => [d.id, true]),\n    )\n\n    this.__store.batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    try {\n      matches = await this.loadMatches({\n        matches,\n        location: next,\n        preload: true,\n        checkLatest: () => undefined,\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        return await this.preloadRoute(err as any)\n      }\n      // Preload errors are not fatal, but we should still log them\n      console.error(err)\n      return undefined\n    }\n  }\n\n  matchRoute = <\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<TRouteTree, TFrom, TTo>,\n    opts?: MatchRouteOptions,\n  ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    if (!baseLocation) {\n      return false\n    }\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, true)) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  // We use a token -> weak map to keep track of deferred promises\n  // that are registered on the server and need to be resolved\n  registeredDeferredsIds = new Map<string, {}>()\n  registeredDeferreds = new WeakMap<{}, DeferredPromiseState<any>>()\n\n  getDeferred = (uid: string) => {\n    const token = this.registeredDeferredsIds.get(uid)\n\n    if (!token) {\n      return undefined\n    }\n\n    return this.registeredDeferreds.get(token)\n  }\n\n  /**\n   * @deprecated Please inject your own html using the `injectHtml` method\n   */\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    warning(\n      false,\n      `The dehydrateData method is deprecated. Please use the injectHtml method to inject your own data.`,\n    )\n\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script id='${id}' suppressHydrationWarning>\n  window[\"__TSR_DEHYDRATED__${escapeJSON(\n    strKey,\n  )}\"] = ${JSON.stringify(this.options.transformer.stringify(data))}\n</script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  /**\n   * @deprecated Please extract your own data from scripts injected using the `injectHtml` method\n   */\n  hydrateData = <T extends any = unknown>(key: any) => {\n    warning(\n      false,\n      `The hydrateData method is deprecated. Please use the extractHtml method to extract your own data.`,\n    )\n\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return this.options.transformer.parse(\n        window[`__TSR_DEHYDRATED__${strKey}` as any] as unknown as string,\n      ) as T\n    }\n\n    return undefined\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    const pickError =\n      this.options.errorSerializer?.serialize ?? defaultSerializeError\n\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) => ({\n          ...pick(d, ['id', 'status', 'updatedAt', 'loaderData']),\n          // If an error occurs server-side during SSRing,\n          // send a small subset of the error to the client\n          error: d.error\n            ? {\n                data: pickError(d.error),\n                __isServerError: true,\n              }\n            : undefined,\n        })),\n      },\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: string) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__?.data\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = this.options.transformer.parse(_ctx) as HydrationCtx\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    let matches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    ).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      if (dehydratedMatch) {\n        const route = this.looseRoutesById[match.routeId]!\n\n        const assets =\n          dehydratedMatch.status === 'notFound' ||\n          dehydratedMatch.status === 'redirected'\n            ? {}\n            : {\n                meta: route.options.meta?.({\n                  params: match.params,\n                  loaderData: dehydratedMatch.loaderData,\n                }),\n                links: route.options.links?.(),\n                scripts: route.options.scripts?.(),\n              }\n\n        return {\n          ...match,\n          ...dehydratedMatch,\n          ...assets,\n        }\n      }\n      return match\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n        lastUpdated: Date.now(),\n      }\n    })\n  }\n\n  handleNotFound = (matches: AnyRouteMatch[], err: NotFoundError) => {\n    const matchesByRouteId = Object.fromEntries(\n      matches.map((match) => [match.routeId, match]),\n    ) as Record<string, AnyRouteMatch>\n\n    // Start at the route that errored or default to the root route\n    let routeCursor =\n      (err.global\n        ? this.looseRoutesById[rootRouteId]\n        : this.looseRoutesById[err.routeId]) ||\n      this.looseRoutesById[rootRouteId]!\n\n    // Go up the tree until we find a route with a notFoundComponent or we hit the root\n    while (\n      !routeCursor.options.notFoundComponent &&\n      !this.options.defaultNotFoundComponent &&\n      routeCursor.id !== rootRouteId\n    ) {\n      routeCursor = routeCursor?.parentRoute\n\n      invariant(\n        routeCursor,\n        'Found invalid route tree while trying to find not-found handler.',\n      )\n    }\n\n    let match = matchesByRouteId[routeCursor.id]\n\n    invariant(match, 'Could not find match for route: ' + routeCursor.id)\n\n    // Assign the error to the match\n    Object.assign(match, {\n      status: 'notFound',\n      error: err,\n      isFetching: false,\n    } as AnyRouteMatch)\n  }\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: { ...location },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    lastUpdated: 0,\n    statusCode: 200,\n  }\n}\n\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n"],"names":["d","searchError","_a","_b","_c","match"],"mappings":"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"}