{"version":3,"file":"route.js","sources":["../../src/route.ts"],"sourcesContent":["import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useLoaderData, useLoaderDeps, useMatch, RouteMatch } from './Matches'\nimport { AnyRouteMatch } from './Matches'\nimport { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { joinPaths, trimPathLeft } from './path'\nimport { RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport { AnyRouter, RegisteredRouter } from './router'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport { BuildLocationFn, NavigateFn } from './RouterProvider'\nimport { NotFoundError, notFound } from './not-found'\nimport { LazyRoute } from './fileRoute'\nimport { useNavigate } from './useNavigate'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type SearchSchemaInput = {\n  __TSearchSchemaInput__: 'TSearchSchemaInput'\n}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport interface StaticDataRouteOption {}\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TSearchSchemaUsed extends Record<string, any> = {},\n  TFullSearchSchemaInput extends Record<string, any> = TSearchSchemaUsed,\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = AnyPathParams,\n  TAllParams extends AnyPathParams = TParams,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn extends any = unknown,\n  TLoaderData extends any = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchemaInput,\n  TSearchSchema,\n  TSearchSchemaUsed,\n  TFullSearchSchemaInput,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContextReturn,\n  TRouteContext,\n  TRouterContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderDataReturn\n> &\n  UpdatableRouteOptions<\n    NoInfer<TAllParams>,\n    NoInfer<TFullSearchSchema>,\n    NoInfer<TLoaderData>\n  >\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\nexport type FileBaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn extends any = unknown,\n> = {\n  validateSearch?: SearchSchemaValidator<TSearchSchemaInput, TSearchSchema>\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TAllParams,\n          TFullSearchSchema,\n          TAllContext,\n          TRouteContext\n        >,\n      ) => any)\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: BeforeLoadFn<\n    TFullSearchSchema,\n    TParentRoute,\n    TAllParams,\n    TRouteContextReturn,\n    TRouterContext\n  >\n  loaderDeps?: (opts: { search: TFullSearchSchema }) => TLoaderDeps\n  loader?: RouteLoaderFn<\n    TAllParams,\n    NoInfer<TLoaderDeps>,\n    NoInfer<TAllContext>,\n    NoInfer<TRouteContext>,\n    TLoaderDataReturn\n  >\n} & (\n  | {\n      // Both or none\n      parseParams?: (\n        rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n      ) => TParams extends Record<ParsePathParams<TPath>, any>\n        ? TParams\n        : 'parseParams must return an object'\n      stringifyParams?: (\n        params: NoInfer<ParamsFallback<TPath, TParams>>,\n      ) => Record<ParsePathParams<TPath>, string>\n    }\n  | {\n      stringifyParams?: never\n      parseParams?: never\n    }\n)\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TSearchSchemaUsed extends Record<string, any> = {},\n  TFullSearchSchemaInput extends Record<string, any> = TSearchSchemaUsed,\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn extends any = unknown,\n> = RoutePathOptions<TCustomId, TPath> &\n  FileBaseRouteOptions<\n    TParentRoute,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn\n  > & {\n    getParentRoute: () => TParentRoute\n  }\n\ntype BeforeLoadFn<\n  TFullSearchSchema extends Record<string, any>,\n  TParentRoute extends AnyRoute,\n  TAllParams,\n  TRouteContextReturn extends RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TContext = IsAny<TParentRoute['types']['allContext'], TRouterContext>,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TContext\n  location: ParsedLocation\n  navigate: NavigateFn\n  buildLocation: BuildLocationFn<TParentRoute>\n  cause: 'preload' | 'enter' | 'stay'\n}) => Promise<TRouteContextReturn> | TRouteContextReturn | void\n\nexport type UpdatableRouteOptions<\n  TAllParams extends Record<string, any>,\n  TFullSearchSchema extends Record<string, any>,\n  TLoaderData extends any,\n> = {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  notFoundComponent?: NotFoundRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: AnyRouteMatch) => void\n  onStay?: (match: AnyRouteMatch) => void\n  onLeave?: (match: AnyRouteMatch) => void\n  meta?: (ctx: {\n    params: TAllParams\n    loaderData: TLoaderData\n  }) =>\n    | JSX.IntrinsicElements['meta'][]\n    | Promise<JSX.IntrinsicElements['meta'][]>\n  links?: () => JSX.IntrinsicElements['link'][]\n  scripts?: () => JSX.IntrinsicElements['script'][]\n  headers?: (ctx: {\n    loaderData: TLoaderData\n  }) => Promise<Record<string, string>> | Record<string, string>\n} & UpdatableStaticRouteOption\n\nexport type UpdatableStaticRouteOption =\n  {} extends PickRequired<StaticDataRouteOption>\n    ? {\n        staticData?: StaticDataRouteOption\n      }\n    : {\n        staticData: StaticDataRouteOption\n      }\n\nexport type MetaDescriptor =\n  | { charSet: 'utf-8' }\n  | { title: string }\n  | { name: string; content: string }\n  | { property: string; content: string }\n  | { httpEquiv: string; content: string }\n  | { 'script:ld+json': LdJsonObject }\n  | { tagName: 'meta' | 'link'; [name: string]: string }\n  | { [name: string]: unknown }\n\ntype LdJsonObject = { [Key in string]: LdJsonValue } & {\n  [Key in string]?: LdJsonValue | undefined\n}\ntype LdJsonArray = LdJsonValue[] | readonly LdJsonValue[]\ntype LdJsonPrimitive = string | number | boolean | null\ntype LdJsonValue = LdJsonPrimitive | LdJsonObject | LdJsonArray\n\nexport type RouteLinkEntry = {}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TInput, TReturn> =\n  | SearchSchemaValidatorObj<TInput, TReturn>\n  | SearchSchemaValidatorFn<TInput, TReturn>\n\nexport type SearchSchemaValidatorObj<TInput, TReturn> = {\n  parse?: SearchSchemaValidatorFn<TInput, TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TInput, TReturn> = (\n  searchObj: TInput,\n) => TReturn\n\nexport type RouteLoaderFn<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = (\n  match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>,\n) => Promise<TLoaderData> | TLoaderData | void\n\nexport interface LoaderFnContext<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  deps: TLoaderDeps\n  context: Expand<Assign<TAllContext, TRouteContext>>\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>\n  parentMatchPromise?: Promise<void>\n  cause: 'preload' | 'enter' | 'stay'\n  route: Route\n}\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type InferFullSearchSchemaInput<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchemaInput: infer TFullSearchSchemaInput\n  }\n}\n  ? TFullSearchSchemaInput\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<\n  Assign<\n    Omit<InferFullSearchSchema<TParentRoute>, keyof RootSearchSchema>,\n    TSearchSchema\n  >\n>\n\nexport type ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed> =\n  Expand<\n    Assign<\n      Omit<InferFullSearchSchemaInput<TParentRoute>, keyof RootSearchSchema>,\n      TSearchSchemaUsed\n    >\n  >\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type ResolveAllParams<\n  TParentRoute extends AnyRoute,\n  TParams extends AnyPathParams,\n> =\n  Record<never, string> extends TParentRoute['types']['allParams']\n    ? TParams\n    : Expand<\n        UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n      >\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport function getRouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema extends Record<\n    string,\n    any\n  > = TRoute['types']['fullSearchSchema'],\n  TAllParams extends AnyPathParams = TRoute['types']['allParams'],\n  TAllContext extends Record<string, any> = TRoute['types']['allContext'],\n  TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'],\n  TLoaderData extends any = TRoute['types']['loaderData'],\n>(id: TId) {\n  return new RouteApi<\n    TId,\n    TRoute,\n    TFullSearchSchema,\n    TAllParams,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderData\n  >({ id })\n}\n\nexport class RouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema extends Record<\n    string,\n    any\n  > = TRoute['types']['fullSearchSchema'],\n  TAllParams extends AnyPathParams = TRoute['types']['allParams'],\n  TAllContext extends Record<string, any> = TRoute['types']['allContext'],\n  TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'],\n  TLoaderData extends any = TRoute['types']['loaderData'],\n> {\n  id: TId\n\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch = <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TRouteMatchState = RouteMatch<TRouteTree, TId>,\n    TSelected = TRouteMatchState,\n  >(opts?: {\n    select?: (match: TRouteMatchState) => TSelected\n  }): TSelected => {\n    return useMatch({ select: opts?.select, from: this.id })\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (s: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (s: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id })\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (s: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useNavigate = () => {\n    return useNavigate({ from: this.id })\n  }\n\n  notFound = (opts?: NotFoundError) => {\n    return notFound({ routeId: this.id as string, ...opts })\n  }\n}\n\nexport class Route<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  in out TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchemaUsed extends Record<\n    string,\n    any\n  > = TSearchSchemaInput extends SearchSchemaInput\n    ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n    : TSearchSchema,\n  TFullSearchSchemaInput extends Record<\n    string,\n    any\n  > = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>,\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = RouteContext,\n  in out TRouteContext extends RouteConstraints['TRouteContext'] = [\n    TRouteContextReturn,\n  ] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  in out TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn extends any = unknown,\n  TLoaderData extends any = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n  lazyFn?: () => Promise<LazyRoute<any>>\n\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TFullSearchSchemaInput,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    searchSchemaInput: TSearchSchemaInput\n    searchSchemaUsed: TSearchSchemaUsed\n    fullSearchSchema: TFullSearchSchema\n    fullSearchSchemaInput: TFullSearchSchemaInput\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routeTree: TRouteTree\n    routerContext: TRouterContext\n    loaderData: TLoaderData\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number }) => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TFullSearchSchemaInput,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    > &\n      RoutePathOptionsIntersection<TCustomId, TPath>\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPathLeft(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TNewChildren,\n    TRouteTree\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  updateLoader = <TNewLoaderData extends any = unknown>(options: {\n    loader: RouteLoaderFn<\n      TAllParams,\n      TLoaderDeps,\n      TAllContext,\n      TRouteContext,\n      TNewLoaderData\n    >\n  }) => {\n    Object.assign(this.options, options)\n    return this as unknown as Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TFullSearchSchemaInput,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TAllContext,\n      TRouterContext,\n      TLoaderDeps,\n      TNewLoaderData,\n      TChildren,\n      TRouteTree\n    >\n  }\n\n  update = (\n    options: UpdatableRouteOptions<TAllParams, TFullSearchSchema, TLoaderData>,\n  ) => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  lazy = (lazyFn: () => Promise<LazyRoute<any>>) => {\n    this.lazyFn = lazyFn\n    return this\n  }\n\n  useMatch = <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TRouteMatchState = RouteMatch<TRouteTree, TId>,\n    TSelected = TRouteMatchState,\n  >(opts?: {\n    select?: (match: TRouteMatchState) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id })\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id })\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any)\n  }\n}\n\nexport function createRoute<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchemaUsed extends Record<\n    string,\n    any\n  > = TSearchSchemaInput extends SearchSchemaInput\n    ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n    : TSearchSchema,\n  TFullSearchSchemaInput extends Record<\n    string,\n    any\n  > = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>,\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = RouteContext,\n  TRouteContext extends RouteConstraints['TRouteContext'] = [\n    TRouteContextReturn,\n  ] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn extends any = unknown,\n  TLoaderData extends any = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n>(\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >,\n) {\n  return new Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TChildren,\n    TRouteTree\n  >(options)\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any>\n\nexport function createRootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n    TSearchSchema extends Record<string, any> = RootSearchSchema,\n    TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n    TRouteContextReturn extends RouteContext = RouteContext,\n    TRouteContext extends RouteContext = [TRouteContextReturn] extends [never]\n      ? RouteContext\n      : TRouteContextReturn,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderDataReturn extends any = unknown,\n    TLoaderData extends any = [TLoaderDataReturn] extends [never]\n      ? undefined\n      : TLoaderDataReturn,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchemaInput, // TSearchSchemaInput\n        TSearchSchema, // TSearchSchema\n        TSearchSchemaUsed,\n        TSearchSchemaUsed, //TFullSearchSchemaInput\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContextReturn, // TRouteContextReturn\n        TRouteContext, // TRouteContext\n        TRouterContext,\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderDataReturn, // TLoaderDataReturn,\n        TLoaderData // TLoaderData,\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) => {\n    return createRootRoute<\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TLoaderDeps,\n      TLoaderData\n    >(options as any)\n  }\n}\n\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\nexport const rootRouteWithContext = createRootRouteWithContext\n\nexport type RootSearchSchema = {\n  __TRootSearchSchema__: '__TRootSearchSchema__'\n}\n\nexport class RootRoute<\n  TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n  TSearchSchema extends Record<string, any> = RootSearchSchema,\n  TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext extends RouteContext = [TRouteContextReturn] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn extends any = unknown,\n  TLoaderData extends any = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchemaInput, // TSearchSchemaInput\n  TSearchSchema, // TSearchSchema\n  TSearchSchemaUsed,\n  TSearchSchemaUsed, // TFullSearchSchemaInput\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContextReturn, // TRouteContextReturn\n  TRouteContext, // TRouteContext\n  Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext\n  TRouterContext, // TRouterContext\n  TLoaderDeps,\n  TLoaderDataReturn,\n  TLoaderData,\n  any, // TChildren\n  any // TRouteTree\n> {\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchemaInput, // TSearchSchemaInput\n        TSearchSchema, // TSearchSchema\n        TSearchSchemaUsed,\n        TSearchSchemaUsed, // TFullSearchSchemaInput\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContextReturn, // TRouteContextReturn\n        TRouteContext, // TRouteContext\n        TRouterContext,\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderDataReturn,\n        TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport function createRootRoute<\n  TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n  TSearchSchema extends Record<string, any> = RootSearchSchema,\n  TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext extends RouteContext = [TRouteContextReturn] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn extends any = unknown,\n  TLoaderData extends any = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n>(\n  options?: Omit<\n    RouteOptions<\n      AnyRoute, // TParentRoute\n      RootRouteId, // TCustomId\n      '', // TPath\n      TSearchSchemaInput, // TSearchSchemaInput\n      TSearchSchema, // TSearchSchema\n      TSearchSchemaUsed,\n      TSearchSchemaUsed, // TFullSearchSchemaInput\n      TSearchSchema, // TFullSearchSchema\n      {}, // TParams\n      {}, // TAllParams\n      TRouteContextReturn, // TRouteContextReturn\n      TRouteContext, // TRouteContext\n      TRouterContext,\n      Assign<TRouterContext, TRouteContext>, // TAllContext\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n    | 'path'\n    | 'id'\n    | 'getParentRoute'\n    | 'caseSensitive'\n    | 'parseParams'\n    | 'stringifyParams'\n  >,\n) {\n  return new RootRoute<\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >(options)\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<TRouteTree, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\n/**\n * @deprecated Use `ErrorComponentProps` instead.\n */\nexport type ErrorRouteProps = {\n  error: unknown\n  info: { componentStack: string }\n}\n\nexport type ErrorComponentProps = {\n  error: unknown\n  info: { componentStack: string }\n}\nexport type NotFoundRouteProps = {\n  // TODO: Make sure this is `| null | undefined` (this is for global not-founds)\n  data: unknown\n}\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = SyncRouteComponent<TProps> &\n  AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorComponentProps>\n\nexport type NotFoundRouteComponent = SyncRouteComponent<NotFoundRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchemaUsed extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchemaInput extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = AnyContext,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn extends any = unknown,\n  TLoaderData extends any = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchSchemaInput,\n  TSearchSchema,\n  TSearchSchemaUsed,\n  TFullSearchSchemaInput,\n  TFullSearchSchema,\n  {},\n  {},\n  TRouteContextReturn,\n  TRouteContext,\n  TAllContext,\n  TRouterContext,\n  TLoaderDeps,\n  TLoaderDataReturn,\n  TLoaderData,\n  TChildren,\n  TRouteTree\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchemaInput,\n        TSearchSchema,\n        TSearchSchemaUsed,\n        TFullSearchSchemaInput,\n        TFullSearchSchema,\n        {},\n        {},\n        TRouteContextReturn,\n        TRouteContext,\n        TRouterContext,\n        TAllContext,\n        TLoaderDeps,\n        TLoaderDataReturn,\n        TLoaderData\n      >,\n      'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n"],"names":["options"],"mappings":"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"}