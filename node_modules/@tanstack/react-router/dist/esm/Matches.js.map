{"version":3,"file":"Matches.js","sources":["../../src/Matches.tsx"],"sourcesContent":["import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { ResolveRelativePath, ToOptions } from './link'\nimport {\n  AnyRoute,\n  ReactNode,\n  RootSearchSchema,\n  StaticDataRouteOption,\n} from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { AnyRouter, RegisteredRouter, RouterState } from './router'\nimport {\n  DeepPartial,\n  Expand,\n  NoInfer,\n  StrictOrFrom,\n  isServer,\n  pick,\n} from './utils'\nimport { CatchNotFound, DefaultGlobalNotFound, isNotFound } from './not-found'\nimport { isRedirect } from './redirects'\n\nexport const matchContext = React.createContext<string | undefined>(undefined)\n\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: TReturnIntersection extends false\n    ? RouteById<TRouteTree, TRouteId>['types']['allParams']\n    : Expand<Partial<AllParams<TRouteTree>>>\n  status: 'pending' | 'success' | 'error' | 'redirected' | 'notFound'\n  isFetching: boolean\n  showPending: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData']\n  routeContext: RouteById<TRouteTree, TRouteId>['types']['routeContext']\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  search: TReturnIntersection extends false\n    ? Exclude<\n        RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema'],\n        RootSearchSchema\n      >\n    : Expand<\n        Partial<Omit<FullSearchSchema<TRouteTree>, keyof RootSearchSchema>>\n      >\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: RouteById<TRouteTree, TRouteId>['types']['loaderDeps']\n  preload: boolean\n  invalid: boolean\n  pendingPromise?: Promise<void>\n  meta?: JSX.IntrinsicElements['meta'][]\n  links?: JSX.IntrinsicElements['link'][]\n  scripts?: JSX.IntrinsicElements['script'][]\n  headers?: Record<string, string>\n  globalNotFound?: boolean\n  staticData: StaticDataRouteOption\n}\n\nexport type AnyRouteMatch = RouteMatch<any, any>\n\nexport function Matches() {\n  const router = useRouter()\n  const matchId = useRouterState({\n    select: (s) => {\n      return getRenderedMatches(s)[0]?.id\n    },\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => router.state.resolvedLocation.state?.key!}\n        errorComponent={ErrorComponent}\n        onCatch={(error) => {\n          warning(\n            false,\n            `The following error wasn't caught by any route! ðŸ‘‡ At the very least, consider setting an 'errorComponent' in your RootRoute!`,\n          )\n          console.error(error)\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matchId }: { matchId: string }) {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${matchId}\". Please file an issue!`,\n  )\n\n  const route = router.routesById[routeId]!\n\n  const PendingComponent = (route.options.pendingComponent ??\n    router.options.defaultPendingComponent) as any\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ?? router.options.defaultErrorComponent\n\n  const routeNotFoundComponent = route.isRoot\n    ? // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n      route.options.notFoundComponent ??\n      router.options.notFoundRoute?.options.component\n    : route.options.notFoundComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ??\n    PendingComponent ??\n    route.options.component?.preload ??\n    route.options.pendingComponent?.preload ??\n    (route.options.errorComponent as any)?.preload\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  const ResolvedNotFoundBoundary = routeNotFoundComponent\n    ? CatchNotFound\n    : SafeFragment\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <ResolvedSuspenseBoundary fallback={pendingElement}>\n        <ResolvedCatchBoundary\n          getResetKey={() => router.state.resolvedLocation.state?.key!}\n          errorComponent={routeErrorComponent ?? ErrorComponent}\n          onCatch={(error) => {\n            // Forward not found errors (we don't want to show the error component for these)\n            if (isNotFound(error)) throw error\n            warning(false, `Error in route match: ${matchId}`)\n            console.error(error)\n          }}\n        >\n          <ResolvedNotFoundBoundary\n            fallback={(error) => {\n              // If the current not found handler doesn't exist or it has a\n              // route ID which doesn't match the current route, rethrow the error\n              if (\n                !routeNotFoundComponent ||\n                (error.routeId && error.routeId !== routeId) ||\n                (!error.routeId && !route.isRoot)\n              )\n                throw error\n\n              return React.createElement(routeNotFoundComponent, error as any)\n            }}\n          >\n            <MatchInner matchId={matchId!} pendingElement={pendingElement} />\n          </ResolvedNotFoundBoundary>\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction MatchInner({\n  matchId,\n  pendingElement,\n}: {\n  matchId: string\n  pendingElement: any\n}): any {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const match = useRouterState({\n    select: (s) =>\n      pick(getRenderedMatches(s).find((d) => d.id === matchId)!, [\n        'status',\n        'error',\n        'showPending',\n        'loadPromise',\n      ]),\n  })\n\n  const RouteErrorComponent =\n    (route.options.errorComponent ?? router.options.defaultErrorComponent) ||\n    ErrorComponent\n\n  if (match.status === 'notFound') {\n    let error: unknown\n    if (isServerSideError(match.error)) {\n      const deserializeError =\n        router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n\n      error = deserializeError(match.error.data)\n    } else {\n      error = match.error\n    }\n\n    invariant(isNotFound(error), 'Expected a notFound error')\n\n    return renderRouteNotFound(router, route, error)\n  }\n\n  if (match.status === 'redirected') {\n    // Redirects should be handled by the router transition. If we happen to\n    // encounter a redirect here, it's a bug. Let's warn, but render nothing.\n    invariant(isRedirect(match.error), 'Expected a redirect error')\n\n    warning(\n      false,\n      'Tried to render a redirected route match! This is a weird circumstance, please file an issue!',\n    )\n\n    return null\n  }\n\n  if (match.status === 'error') {\n    // If we're on the server, we need to use React's new and super\n    // wonky api for throwing errors from a server side render inside\n    // of a suspense boundary. This is the only way to get\n    // renderToPipeableStream to not hang indefinitely.\n    // We'll serialize the error and rethrow it on the client.\n    if (isServer) {\n      return (\n        <RouteErrorComponent\n          error={match.error}\n          info={{\n            componentStack: '',\n          }}\n        />\n      )\n    }\n\n    if (isServerSideError(match.error)) {\n      const deserializeError =\n        router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n      throw deserializeError(match.error.data)\n    } else {\n      throw match.error\n    }\n  }\n\n  if (match.status === 'pending') {\n    if (match.showPending) {\n      return pendingElement\n    }\n    throw match.loadPromise\n  }\n\n  if (match.status === 'success') {\n    let Comp = route.options.component ?? router.options.defaultComponent\n\n    if (Comp) {\n      return <Comp />\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport const Outlet = React.memo(function Outlet() {\n  const router = useRouter()\n  const matchId = React.useContext(matchContext)\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const { parentGlobalNotFound } = useRouterState({\n    select: (s) => {\n      const matches = getRenderedMatches(s)\n      const parentMatch = matches.find((d) => d.id === matchId)\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId}\"`,\n      )\n      return {\n        parentGlobalNotFound: parentMatch.globalNotFound,\n      }\n    },\n  })\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = getRenderedMatches(s)\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, undefined)\n  }\n\n  if (!childMatchId) {\n    return null\n  }\n\n  return <Match matchId={childMatchId} />\n})\n\nfunction renderRouteNotFound(router: AnyRouter, route: AnyRoute, data: any) {\n  if (!route.options.notFoundComponent) {\n    if (router.options.defaultNotFoundComponent) {\n      return <router.options.defaultNotFoundComponent data={data} />\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      warning(\n        route.options.notFoundComponent,\n        `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<div>Not Found<div>)`,\n      )\n    }\n\n    return <DefaultGlobalNotFound />\n  }\n\n  return <route.options.notFoundComponent data={data} />\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type UseMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n  Options extends ToOptions<\n    TRouteTree,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  > = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n  RelaxedOptions = Omit<Options, 'search' | 'params'> &\n    DeepPartial<Pick<Options, 'search' | 'params'>>,\n> = RelaxedOptions & MatchRouteOptions\n\nexport function useMatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>() {\n  useRouterState({ select: (s) => [s.location, s.resolvedLocation] })\n  const { matchRoute } = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n\n      return matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch,\n      })\n    },\n    [],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | ((\n        params?: RouteByPath<\n          TRouteTree,\n          ResolveRelativePath<TFrom, NoInfer<TTo>>\n        >['types']['allParams'],\n      ) => ReactNode)\n    | React.ReactNode\n}\n\nexport function MatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return !!params ? props.children : null\n}\n\nexport function getRenderedMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(state: RouterState<TRouteTree>) {\n  return state.pendingMatches?.some((d) => d.showPending)\n    ? state.pendingMatches\n    : state.matches\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TReturnIntersection extends boolean = false,\n  TRouteMatchState = RouteMatch<TRouteTree, TFrom, TReturnIntersection>,\n  TSelected = TRouteMatchState,\n>(\n  opts: StrictOrFrom<TFrom, TReturnIntersection> & {\n    select?: (match: TRouteMatchState) => TSelected\n  },\n): TSelected {\n  const nearestMatchId = React.useContext(matchContext)\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = getRenderedMatches(state).find((d) =>\n        opts?.from ? opts?.from === d.routeId : d.id === nearestMatchId,\n      )\n\n      invariant(\n        match,\n        `Could not find ${\n          opts?.from\n            ? `an active match from \"${opts.from}\"`\n            : 'a nearest match!'\n        }`,\n      )\n\n      return opts?.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as any\n}\n\nexport function useMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = TRouteMatch[],\n>(opts?: {\n  select?: (matches: TRouteMatch[]) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  return useRouterState({\n    select: (state) => {\n      const matches = getRenderedMatches(state)\n      return opts?.select\n        ? opts.select(matches as TRouteMatch[])\n        : (matches as T)\n    },\n  })\n}\n\nexport function useParentMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = TRouteMatch[],\n>(opts?: {\n  select?: (matches: TRouteMatch[]) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId),\n      )\n      return opts?.select\n        ? opts.select(matches as TRouteMatch[])\n        : (matches as T)\n    },\n  })\n}\n\nexport function useChildMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = TRouteMatch[],\n>(opts?: {\n  select?: (matches: TRouteMatch[]) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1,\n      )\n      return opts?.select\n        ? opts.select(matches as TRouteMatch[])\n        : (matches as T)\n    },\n  })\n}\n\nexport function useLoaderDeps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderDeps'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderDeps)\n        : s?.loaderDeps\n    },\n  })\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderData'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderData)\n        : s?.loaderData\n    },\n  })\n}\n\nexport function isServerSideError(error: unknown): error is {\n  __isServerError: true\n  data: Record<string, any>\n} {\n  if (!(typeof error === 'object' && error && 'data' in error)) return false\n  if (!('__isServerError' in error && error.__isServerError)) return false\n  if (!(typeof error.data === 'object' && error.data)) return false\n\n  return error.__isServerError === true\n}\n\nexport function defaultDeserializeError(serializedData: Record<string, any>) {\n  if ('name' in serializedData && 'message' in serializedData) {\n    const error = new Error(serializedData.message)\n    error.name = serializedData.name\n    if (process.env.NODE_ENV === 'development') {\n      error.stack = serializedData.stack\n    }\n    return error\n  }\n\n  return serializedData.data\n}\n"],"names":["_a","Outlet"],"mappings":"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"}