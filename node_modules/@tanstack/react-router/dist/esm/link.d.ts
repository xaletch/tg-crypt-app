import * as React from 'react';
import { Trim } from './fileRoute.js';
import { AnyRoute, RootSearchSchema } from './route.js';
import { RouteByPath, RoutePaths, RoutePathsAutoComplete } from './routeInfo.js';
import { RegisteredRouter } from './router.js';
import { Expand, IsUnion, MakeDifferenceOptional, NoInfer, NonNullableUpdater, PickRequired, Updater, WithoutEmpty } from './utils.js';
import { HistoryState } from '@tanstack/history';
export type CleanPath<T extends string> = T extends `${infer L}//${infer R}` ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`> : T extends `${infer L}//` ? `${CleanPath<L>}/` : T extends `//${infer L}` ? `/${CleanPath<L>}` : T;
export type Split<S, TIncludeTrailingSlash = true> = S extends unknown ? string extends S ? string[] : S extends string ? CleanPath<S> extends '' ? [] : TIncludeTrailingSlash extends true ? CleanPath<S> extends `${infer T}/` ? [...Split<T>, '/'] : CleanPath<S> extends `/${infer U}` ? Split<U> : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : [S] : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : S extends string ? [S] : never : never : never;
export type ParsePathParams<T extends string> = keyof {
    [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L extends '' ? '_splat' : L : never]: K;
};
export type Join<T, Delimiter extends string = '/'> = T extends [] ? '' : T extends [infer L extends string] ? L : T extends [infer L extends string, ...infer Tail extends [...string[]]] ? CleanPath<`${L}${Delimiter}${Join<Tail>}`> : never;
export type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;
export type RemoveTrailingSlashes<T> = T extends `${infer R}/` ? RemoveTrailingSlashes<R> : T;
export type RemoveLeadingSlashes<T> = T extends `/${infer R}` ? RemoveLeadingSlashes<R> : T;
export type SearchPaths<TPaths, TSearchPath extends string> = TPaths extends `${TSearchPath}/${infer TRest}` ? TRest : never;
export type SearchRelativePathAutoComplete<TTo extends string, TSearchPath extends string, TPaths, SearchedPaths = SearchPaths<TPaths, TSearchPath>> = SearchedPaths extends string ? `${TTo}/${SearchedPaths}` : never;
export type RelativeToParentPathAutoComplete<TFrom extends string, TTo extends string, TPaths, TResolvedPath extends string = RemoveTrailingSlashes<ResolveRelativePath<TFrom, TTo>>> = SearchRelativePathAutoComplete<TTo, TResolvedPath, TPaths> | (TResolvedPath extends '' ? never : `${TTo}/../`);
export type RelativeToCurrentPathAutoComplete<TFrom extends string, TTo extends string, TRestTo extends string, TPaths, TResolvedPath extends string = RemoveTrailingSlashes<`${RemoveTrailingSlashes<TFrom>}/${RemoveLeadingSlashes<TRestTo>}`>> = SearchRelativePathAutoComplete<TTo, TResolvedPath, TPaths>;
export type AbsolutePathAutoComplete<TFrom extends string, TPaths> = (string extends TFrom ? './' : TFrom extends `/` ? never : SearchPaths<TPaths, RemoveTrailingSlashes<TFrom>> extends infer SearchedPaths ? SearchedPaths extends '' ? never : './' : never) | (string extends TFrom ? '../' : TFrom extends `/` ? never : '../') | TPaths;
export type RelativeToPathAutoComplete<TRouteTree extends AnyRoute, TFrom extends string, TTo extends string, TPaths = RoutePaths<TRouteTree>> = TTo extends `..${string}` ? RelativeToParentPathAutoComplete<TFrom, RemoveTrailingSlashes<TTo>, TPaths> : TTo extends `./${infer TRestTTo}` ? RelativeToCurrentPathAutoComplete<TFrom, RemoveTrailingSlashes<TTo>, TRestTTo, TPaths> : AbsolutePathAutoComplete<TFrom, TPaths>;
export type NavigateOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    replace?: boolean;
    resetScroll?: boolean;
    startTransition?: boolean;
};
export type ToOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = ToSubOptions<TRouteTree, TFrom, TTo> & {
    mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>;
};
export type ToMaskOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TMaskFrom extends RoutePaths<TRouteTree> | string = string, TMaskTo extends string = ''> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {
    unmaskOnReload?: boolean;
};
export type ToSubOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = ''> = {
    to?: ToPathOption<TRouteTree, TFrom, TTo>;
    hash?: true | Updater<string>;
    state?: true | NonNullableUpdater<HistoryState>;
    from?: RoutePathsAutoComplete<TRouteTree, TFrom>;
} & CheckPath<TRouteTree, {}, TFrom, TTo> & SearchParamOptions<TRouteTree, TFrom, TTo> & PathParamOptions<TRouteTree, TFrom, TTo>;
type ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo);
type ParamVariant = 'PATH' | 'SEARCH';
type ExcludeRootSearchSchema<T, Excluded = Exclude<T, RootSearchSchema>> = [
    Excluded
] extends [never] ? {} : Excluded;
export type ResolveRoute<TRouteTree extends AnyRoute, TFrom, TTo, TPath = RemoveTrailingSlashes<string extends TFrom ? TTo : string extends TTo ? TFrom : ResolveRelativePath<TFrom, TTo>>> = RouteByPath<TRouteTree, `${TPath & string}/`> extends never ? RouteByPath<TRouteTree, TPath> : RouteByPath<TRouteTree, `${TPath & string}/`>;
type PostProcessParams<T, TParamVariant extends ParamVariant> = TParamVariant extends 'SEARCH' ? ExcludeRootSearchSchema<T> : T;
export type ParamOptions<TRouteTree extends AnyRoute, TFrom, TTo extends string, TParamVariant extends ParamVariant, TFromRouteType extends 'allParams' | 'fullSearchSchema' = TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchema', TToRouteType extends 'allParams' | 'fullSearchSchemaInput' = TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchemaInput', TFromParams = PostProcessParams<RouteByPath<TRouteTree, TFrom>['types'][TFromRouteType], TParamVariant>, TToParams = PostProcessParams<ResolveRoute<TRouteTree, TFrom, TTo>['types'][TToRouteType], TParamVariant>, TRelativeToParams = TParamVariant extends 'SEARCH' ? TToParams : true extends IsUnion<TFromParams> ? TToParams : MakeDifferenceOptional<TFromParams, TToParams>, TReducer = ParamsReducer<TFromParams, TRelativeToParams>> = keyof PickRequired<TRelativeToParams> extends never ? Partial<MakeParamOption<TParamVariant, true | TReducer>> : TFromParams extends Expand<WithoutEmpty<PickRequired<TRelativeToParams>>> ? MakeParamOption<TParamVariant, true | TReducer> : MakeParamOption<TParamVariant, TReducer>;
type MakeParamOption<TParamVariant extends ParamVariant, T> = TParamVariant extends 'PATH' ? MakePathParamOptions<T> : MakeSearchParamOptions<T>;
type MakeSearchParamOptions<T> = {
    search: T;
};
type MakePathParamOptions<T> = {
    params: T;
};
export type SearchParamOptions<TRouteTree extends AnyRoute, TFrom, TTo extends string> = ParamOptions<TRouteTree, TFrom, TTo, 'SEARCH'>;
export type PathParamOptions<TRouteTree extends AnyRoute, TFrom, TTo extends string> = ParamOptions<TRouteTree, TFrom, TTo, 'PATH'>;
export type ToPathOption<TRouteTree extends AnyRoute = AnyRoute, TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = ''> = TTo | RelativeToPathAutoComplete<TRouteTree, NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
export interface ActiveOptions {
    exact?: boolean;
    includeHash?: boolean;
    includeSearch?: boolean;
}
export type LinkOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    target?: HTMLAnchorElement['target'];
    activeOptions?: ActiveOptions;
    preload?: false | 'intent';
    preloadDelay?: number;
    disabled?: boolean;
};
export type CheckPath<TRouteTree extends AnyRoute, TPass, TFrom, TTo> = ResolveRoute<TRouteTree, TFrom, TTo> extends never ? CheckPathError<TRouteTree> : TPass;
export type CheckPathError<TRouteTree extends AnyRoute> = {
    to: RoutePaths<TRouteTree>;
};
export type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string ? TTo extends string ? TTo extends '.' ? TFrom : TTo extends `./` ? Join<[TFrom, '/']> : TTo extends `./${infer TRest}` ? ResolveRelativePath<TFrom, TRest> : TTo extends `/${infer TRest}` ? TTo : Split<TTo> extends ['..', ...infer ToRest] ? Split<TFrom> extends [...infer FromRest, infer FromTail] ? ToRest extends ['/'] ? Join<['/', ...FromRest, '/']> : ResolveRelativePath<Join<FromRest>, Join<ToRest>> : never : Split<TTo> extends ['.', ...infer ToRest] ? ToRest extends ['/'] ? Join<[TFrom, '/']> : ResolveRelativePath<TFrom, Join<ToRest>> : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>> : never : never;
export declare function useLinkProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''>(options: UseLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): React.AnchorHTMLAttributes<HTMLAnchorElement>;
export type UseLinkPropsOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>;
export type ActiveLinkOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    activeProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
    inactiveProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
};
export type LinkProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    children?: React.ReactNode | ((state: {
        isActive: boolean;
    }) => React.ReactNode);
};
type LinkComponent<TComp> = <TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''>(props: React.PropsWithoutRef<LinkProps<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & (TComp extends React.FC<infer TProps> | React.Component<infer TProps> ? TProps : TComp extends keyof JSX.IntrinsicElements ? Omit<React.HTMLProps<TComp>, 'children' | 'preload'> : never)> & React.RefAttributes<TComp extends React.FC<{
    ref: infer TRef;
}> | React.Component<{
    ref: infer TRef;
}> ? TRef : TComp extends keyof JSX.IntrinsicElements ? React.ComponentRef<TComp> : never>) => React.ReactElement;
export declare function createLink<const TComp>(Comp: TComp): LinkComponent<TComp>;
export declare const Link: LinkComponent<'a'>;
export {};
