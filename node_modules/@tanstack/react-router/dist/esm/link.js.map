{"version":3,"file":"link.js","sources":["../../src/link.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { Trim } from './fileRoute'\nimport { AnyRoute, RootSearchSchema } from './route'\nimport { RouteByPath, RoutePaths, RoutePathsAutoComplete } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport {\n  Expand,\n  IsUnion,\n  MakeDifferenceOptional,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  Updater,\n  WithoutEmpty,\n  deepEqual,\n  functionalUpdate,\n} from './utils'\nimport { HistoryState } from '@tanstack/history'\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n    ? `${CleanPath<L>}/`\n    : T extends `//${infer L}`\n      ? `/${CleanPath<L>}`\n      : T\n\nexport type Split<S, TIncludeTrailingSlash = true> = S extends unknown\n  ? string extends S\n    ? string[]\n    : S extends string\n      ? CleanPath<S> extends ''\n        ? []\n        : TIncludeTrailingSlash extends true\n          ? CleanPath<S> extends `${infer T}/`\n            ? [...Split<T>, '/']\n            : CleanPath<S> extends `/${infer U}`\n              ? Split<U>\n              : CleanPath<S> extends `${infer T}/${infer U}`\n                ? [...Split<T>, ...Split<U>]\n                : [S]\n          : CleanPath<S> extends `${infer T}/${infer U}`\n            ? [...Split<T>, ...Split<U>]\n            : S extends string\n              ? [S]\n              : never\n      : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}`\n    ? L extends ''\n      ? '_splat'\n      : L\n    : never]: K\n}\n\nexport type Join<T, Delimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n    ? L\n    : T extends [infer L extends string, ...infer Tail extends [...string[]]]\n      ? CleanPath<`${L}${Delimiter}${Join<Tail>}`>\n      : never\n\nexport type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never\n\nexport type RemoveTrailingSlashes<T> = T extends `${infer R}/`\n  ? RemoveTrailingSlashes<R>\n  : T\n\nexport type RemoveLeadingSlashes<T> = T extends `/${infer R}`\n  ? RemoveLeadingSlashes<R>\n  : T\n\nexport type SearchPaths<\n  TPaths,\n  TSearchPath extends string,\n> = TPaths extends `${TSearchPath}/${infer TRest}` ? TRest : never\n\nexport type SearchRelativePathAutoComplete<\n  TTo extends string,\n  TSearchPath extends string,\n  TPaths,\n  SearchedPaths = SearchPaths<TPaths, TSearchPath>,\n> = SearchedPaths extends string ? `${TTo}/${SearchedPaths}` : never\n\nexport type RelativeToParentPathAutoComplete<\n  TFrom extends string,\n  TTo extends string,\n  TPaths,\n  TResolvedPath extends string = RemoveTrailingSlashes<\n    ResolveRelativePath<TFrom, TTo>\n  >,\n> =\n  | SearchRelativePathAutoComplete<TTo, TResolvedPath, TPaths>\n  | (TResolvedPath extends '' ? never : `${TTo}/../`)\n\nexport type RelativeToCurrentPathAutoComplete<\n  TFrom extends string,\n  TTo extends string,\n  TRestTo extends string,\n  TPaths,\n  TResolvedPath extends\n    string = RemoveTrailingSlashes<`${RemoveTrailingSlashes<TFrom>}/${RemoveLeadingSlashes<TRestTo>}`>,\n> = SearchRelativePathAutoComplete<TTo, TResolvedPath, TPaths>\n\nexport type AbsolutePathAutoComplete<TFrom extends string, TPaths> =\n  | (string extends TFrom\n      ? './'\n      : TFrom extends `/`\n        ? never\n        : SearchPaths<\n              TPaths,\n              RemoveTrailingSlashes<TFrom>\n            > extends infer SearchedPaths\n          ? SearchedPaths extends ''\n            ? never\n            : './'\n          : never)\n  | (string extends TFrom ? '../' : TFrom extends `/` ? never : '../')\n  | TPaths\n\nexport type RelativeToPathAutoComplete<\n  TRouteTree extends AnyRoute,\n  TFrom extends string,\n  TTo extends string,\n  TPaths = RoutePaths<TRouteTree>,\n> = TTo extends `..${string}`\n  ? RelativeToParentPathAutoComplete<TFrom, RemoveTrailingSlashes<TTo>, TPaths>\n  : TTo extends `./${infer TRestTTo}`\n    ? RelativeToCurrentPathAutoComplete<\n        TFrom,\n        RemoveTrailingSlashes<TTo>,\n        TRestTTo,\n        TPaths\n      >\n    : AbsolutePathAutoComplete<TFrom, TPaths>\n\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TFrom, TTo> & {\n  mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TMaskFrom extends RoutePaths<TRouteTree> | string = string,\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = {\n  to?: ToPathOption<TRouteTree, TFrom, TTo>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: RoutePathsAutoComplete<TRouteTree, TFrom>\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n} & CheckPath<TRouteTree, {}, TFrom, TTo> &\n  SearchParamOptions<TRouteTree, TFrom, TTo> &\n  PathParamOptions<TRouteTree, TFrom, TTo>\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\ntype ParamVariant = 'PATH' | 'SEARCH'\ntype ExcludeRootSearchSchema<T, Excluded = Exclude<T, RootSearchSchema>> = [\n  Excluded,\n] extends [never]\n  ? {}\n  : Excluded\n\nexport type ResolveRoute<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TPath = RemoveTrailingSlashes<\n    string extends TFrom\n      ? TTo\n      : string extends TTo\n        ? TFrom\n        : ResolveRelativePath<TFrom, TTo>\n  >,\n> =\n  RouteByPath<TRouteTree, `${TPath & string}/`> extends never\n    ? RouteByPath<TRouteTree, TPath>\n    : RouteByPath<TRouteTree, `${TPath & string}/`>\n\ntype PostProcessParams<\n  T,\n  TParamVariant extends ParamVariant,\n> = TParamVariant extends 'SEARCH' ? ExcludeRootSearchSchema<T> : T\n\nexport type ParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo extends string,\n  TParamVariant extends ParamVariant,\n  TFromRouteType extends\n    | 'allParams'\n    | 'fullSearchSchema' = TParamVariant extends 'PATH'\n    ? 'allParams'\n    : 'fullSearchSchema',\n  TToRouteType extends\n    | 'allParams'\n    | 'fullSearchSchemaInput' = TParamVariant extends 'PATH'\n    ? 'allParams'\n    : 'fullSearchSchemaInput',\n  TFromParams = PostProcessParams<\n    RouteByPath<TRouteTree, TFrom>['types'][TFromRouteType],\n    TParamVariant\n  >,\n  TToParams = PostProcessParams<\n    ResolveRoute<TRouteTree, TFrom, TTo>['types'][TToRouteType],\n    TParamVariant\n  >,\n  TRelativeToParams = TParamVariant extends 'SEARCH'\n    ? TToParams\n    : true extends IsUnion<TFromParams>\n      ? TToParams\n      : MakeDifferenceOptional<TFromParams, TToParams>,\n  TReducer = ParamsReducer<TFromParams, TRelativeToParams>,\n> = keyof PickRequired<TRelativeToParams> extends never\n  ? Partial<MakeParamOption<TParamVariant, true | TReducer>>\n  : TFromParams extends Expand<WithoutEmpty<PickRequired<TRelativeToParams>>>\n    ? MakeParamOption<TParamVariant, true | TReducer>\n    : MakeParamOption<TParamVariant, TReducer>\n\ntype MakeParamOption<\n  TParamVariant extends ParamVariant,\n  T,\n> = TParamVariant extends 'PATH'\n  ? MakePathParamOptions<T>\n  : MakeSearchParamOptions<T>\ntype MakeSearchParamOptions<T> = { search: T }\ntype MakePathParamOptions<T> = { params: T }\n\nexport type SearchParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo extends string,\n> = ParamOptions<TRouteTree, TFrom, TTo, 'SEARCH'>\n\nexport type PathParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo extends string,\n> = ParamOptions<TRouteTree, TFrom, TTo, 'PATH'>\n\nexport type ToPathOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      TRouteTree,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckPath<TRouteTree extends AnyRoute, TPass, TFrom, TTo> =\n  ResolveRoute<TRouteTree, TFrom, TTo> extends never\n    ? CheckPathError<TRouteTree>\n    : TPass\n\nexport type CheckPathError<TRouteTree extends AnyRoute> = {\n  to: RoutePaths<TRouteTree>\n}\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n        ? Join<[TFrom, '/']>\n        : TTo extends `./${infer TRest}`\n          ? ResolveRelativePath<TFrom, TRest>\n          : TTo extends `/${infer TRest}`\n            ? TTo\n            : Split<TTo> extends ['..', ...infer ToRest]\n              ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n                ? ToRest extends ['/']\n                  ? Join<['/', ...FromRest, '/']>\n                  : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n                : never\n              : Split<TTo> extends ['.', ...infer ToRest]\n                ? ToRest extends ['/']\n                  ? Join<[TFrom, '/']>\n                  : ResolveRelativePath<TFrom, Join<ToRest>>\n                : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nexport function useLinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n\n  const {\n    // custom props\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  const dest = {\n    from: options.to ? matchPathname : undefined,\n    ...options,\n  }\n\n  let type: 'internal' | 'external' = 'internal'\n\n  try {\n    new URL(`${to}`)\n    type = 'external'\n  } catch {}\n\n  const next = router.buildLocation(dest as any)\n  const preload = userPreload ?? router.options.defaultPreload\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      // Compare path/hash for matches\n      const currentPathSplit = s.location.pathname.split('/')\n      const nextPathSplit = next.pathname.split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact\n        ? s.location.pathname === next.pathname\n        : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash\n        ? s.location.hash === next.hash\n        : true\n      const searchTest =\n        activeOptions?.includeSearch ?? true\n          ? deepEqual(s.location.search, next.search, !activeOptions?.exact)\n          : true\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest\n    },\n  })\n\n  if (type === 'external') {\n    return {\n      ...rest,\n      type,\n      href: to,\n      children,\n      target,\n      disabled,\n      style,\n      className,\n      onClick,\n      onFocus,\n      onMouseEnter,\n      onMouseLeave,\n      onTouchStart,\n    }\n  }\n\n  // The click handler\n  const handleClick = (e: MouseEvent) => {\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      // All is well? Navigate!\n      router.commitLocation({ ...next, replace, resetScroll, startTransition })\n    }\n  }\n\n  const doPreload = () => {\n    React.startTransition(() => {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    })\n  }\n\n  // The click handler\n  const handleFocus = (e: MouseEvent) => {\n    if (disabled) return\n    if (preload) {\n      doPreload()\n    }\n  }\n\n  const handleTouchStart = handleFocus\n\n  const handleEnter = (e: MouseEvent) => {\n    if (disabled) return\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (preload) {\n      if (target.preloadTimeout) {\n        return\n      }\n\n      target.preloadTimeout = setTimeout(() => {\n        target.preloadTimeout = null\n        doPreload()\n      }, preloadDelay)\n    }\n  }\n\n  const handleLeave = (e: MouseEvent) => {\n    if (disabled) return\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (target.preloadTimeout) {\n      clearTimeout(target.preloadTimeout)\n      target.preloadTimeout = null\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n        ? next.maskedLocation.href\n        : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport type UseLinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type ActiveLinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n\nexport type LinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | React.ReactNode\n    | ((state: { isActive: boolean }) => React.ReactNode)\n}\n\ntype LinkComponent<TComp> = <\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  props: React.PropsWithoutRef<\n    LinkProps<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n      (TComp extends React.FC<infer TProps> | React.Component<infer TProps>\n        ? TProps\n        : TComp extends keyof JSX.IntrinsicElements\n          ? Omit<React.HTMLProps<TComp>, 'children' | 'preload'>\n          : never)\n  > &\n    React.RefAttributes<\n      TComp extends\n        | React.FC<{ ref: infer TRef }>\n        | React.Component<{ ref: infer TRef }>\n        ? TRef\n        : TComp extends keyof JSX.IntrinsicElements\n          ? React.ComponentRef<TComp>\n          : never\n    >,\n) => React.ReactElement\n\nexport function createLink<const TComp>(Comp: TComp): LinkComponent<TComp> {\n  return React.forwardRef(function Link(props, ref) {\n    return <Link {...(props as any)} _asChild={Comp} ref={ref} />\n  }) as any\n}\n\nexport const Link: LinkComponent<'a'> = React.forwardRef((props: any, ref) => {\n  const { _asChild, ...rest } = props\n  const { type, ...linkProps } = useLinkProps(rest as any)\n\n  const children =\n    typeof rest.children === 'function'\n      ? rest.children({\n          isActive: (linkProps as any)['data-status'] === 'active',\n        })\n      : rest.children\n\n  return React.createElement(\n    _asChild ? _asChild : 'a',\n    {\n      ...linkProps,\n      ref,\n    },\n    children as any,\n  )\n}) as any\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n"],"names":["target","Link"],"mappings":"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"}