import * as React from 'react';
import { RouteMatch } from './Matches.cjs';
import { AnyRouteMatch } from './Matches.cjs';
import { NavigateOptions, ParsePathParams, ToSubOptions } from './link.cjs';
import { ParsedLocation } from './location.cjs';
import { RouteById, RouteIds, RoutePaths } from './routeInfo.cjs';
import { AnyRouter, RegisteredRouter } from './router.cjs';
import { Assign, Expand, IsAny, NoInfer, PickRequired, UnionToIntersection } from './utils.cjs';
import { BuildLocationFn, NavigateFn } from './RouterProvider.cjs';
import { NotFoundError } from './not-found.cjs';
import { LazyRoute } from './fileRoute.cjs';
export declare const rootRouteId: "__root__";
export type RootRouteId = typeof rootRouteId;
export type AnyPathParams = {};
export type SearchSchemaInput = {
    __TSearchSchemaInput__: 'TSearchSchemaInput';
};
export type AnySearchSchema = {};
export type AnyContext = {};
export interface RouteContext {
}
export type PreloadableObj = {
    preload?: () => Promise<void>;
};
export type RoutePathOptions<TCustomId, TPath> = {
    path: TPath;
} | {
    id: TCustomId;
};
export interface StaticDataRouteOption {
}
export type RoutePathOptionsIntersection<TCustomId, TPath> = UnionToIntersection<RoutePathOptions<TCustomId, TPath>>;
export type RouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchSchemaInput extends Record<string, any> = {}, TSearchSchema extends Record<string, any> = {}, TSearchSchemaUsed extends Record<string, any> = {}, TFullSearchSchemaInput extends Record<string, any> = TSearchSchemaUsed, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = AnyPathParams, TAllParams extends AnyPathParams = TParams, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = RouteContext, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TAllContext extends Record<string, any> = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends any = unknown, TLoaderData extends any = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn> = BaseRouteOptions<TParentRoute, TCustomId, TPath, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn> & UpdatableRouteOptions<NoInfer<TAllParams>, NoInfer<TFullSearchSchema>, NoInfer<TLoaderData>>;
export type ParamsFallback<TPath extends string, TParams> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams;
export type FileBaseRouteOptions<TParentRoute extends AnyRoute = AnyRoute, TPath extends string = string, TSearchSchemaInput extends Record<string, any> = {}, TSearchSchema extends Record<string, any> = {}, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = {}, TAllParams = ParamsFallback<TPath, TParams>, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = RouteContext, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TAllContext extends Record<string, any> = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends any = unknown> = {
    validateSearch?: SearchSchemaValidator<TSearchSchemaInput, TSearchSchema>;
    shouldReload?: boolean | ((match: LoaderFnContext<TAllParams, TFullSearchSchema, TAllContext, TRouteContext>) => any);
    beforeLoad?: BeforeLoadFn<TFullSearchSchema, TParentRoute, TAllParams, TRouteContextReturn, TRouterContext>;
    loaderDeps?: (opts: {
        search: TFullSearchSchema;
    }) => TLoaderDeps;
    loader?: RouteLoaderFn<TAllParams, NoInfer<TLoaderDeps>, NoInfer<TAllContext>, NoInfer<TRouteContext>, TLoaderDataReturn>;
} & ({
    parseParams?: (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
    stringifyParams?: (params: NoInfer<ParamsFallback<TPath, TParams>>) => Record<ParsePathParams<TPath>, string>;
} | {
    stringifyParams?: never;
    parseParams?: never;
});
export type BaseRouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchSchemaInput extends Record<string, any> = {}, TSearchSchema extends Record<string, any> = {}, TSearchSchemaUsed extends Record<string, any> = {}, TFullSearchSchemaInput extends Record<string, any> = TSearchSchemaUsed, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = {}, TAllParams = ParamsFallback<TPath, TParams>, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = RouteContext, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TAllContext extends Record<string, any> = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends any = unknown> = RoutePathOptions<TCustomId, TPath> & FileBaseRouteOptions<TParentRoute, TPath, TSearchSchemaInput, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn> & {
    getParentRoute: () => TParentRoute;
};
type BeforeLoadFn<TFullSearchSchema extends Record<string, any>, TParentRoute extends AnyRoute, TAllParams, TRouteContextReturn extends RouteContext, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TContext = IsAny<TParentRoute['types']['allContext'], TRouterContext>> = (opts: {
    search: TFullSearchSchema;
    abortController: AbortController;
    preload: boolean;
    params: TAllParams;
    context: TContext;
    location: ParsedLocation;
    navigate: NavigateFn;
    buildLocation: BuildLocationFn<TParentRoute>;
    cause: 'preload' | 'enter' | 'stay';
}) => Promise<TRouteContextReturn> | TRouteContextReturn | void;
export type UpdatableRouteOptions<TAllParams extends Record<string, any>, TFullSearchSchema extends Record<string, any>, TLoaderData extends any> = {
    caseSensitive?: boolean;
    wrapInSuspense?: boolean;
    component?: RouteComponent;
    errorComponent?: false | null | ErrorRouteComponent;
    notFoundComponent?: NotFoundRouteComponent;
    pendingComponent?: RouteComponent;
    pendingMs?: number;
    pendingMinMs?: number;
    staleTime?: number;
    gcTime?: number;
    preloadStaleTime?: number;
    preloadGcTime?: number;
    preSearchFilters?: SearchFilter<TFullSearchSchema>[];
    postSearchFilters?: SearchFilter<TFullSearchSchema>[];
    onError?: (err: any) => void;
    onEnter?: (match: AnyRouteMatch) => void;
    onStay?: (match: AnyRouteMatch) => void;
    onLeave?: (match: AnyRouteMatch) => void;
    meta?: (ctx: {
        params: TAllParams;
        loaderData: TLoaderData;
    }) => JSX.IntrinsicElements['meta'][] | Promise<JSX.IntrinsicElements['meta'][]>;
    links?: () => JSX.IntrinsicElements['link'][];
    scripts?: () => JSX.IntrinsicElements['script'][];
    headers?: (ctx: {
        loaderData: TLoaderData;
    }) => Promise<Record<string, string>> | Record<string, string>;
} & UpdatableStaticRouteOption;
export type UpdatableStaticRouteOption = {} extends PickRequired<StaticDataRouteOption> ? {
    staticData?: StaticDataRouteOption;
} : {
    staticData: StaticDataRouteOption;
};
export type MetaDescriptor = {
    charSet: 'utf-8';
} | {
    title: string;
} | {
    name: string;
    content: string;
} | {
    property: string;
    content: string;
} | {
    httpEquiv: string;
    content: string;
} | {
    'script:ld+json': LdJsonObject;
} | {
    tagName: 'meta' | 'link';
    [name: string]: string;
} | {
    [name: string]: unknown;
};
type LdJsonObject = {
    [Key in string]: LdJsonValue;
} & {
    [Key in string]?: LdJsonValue | undefined;
};
type LdJsonArray = LdJsonValue[] | readonly LdJsonValue[];
type LdJsonPrimitive = string | number | boolean | null;
type LdJsonValue = LdJsonPrimitive | LdJsonObject | LdJsonArray;
export type RouteLinkEntry = {};
export type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<TPath, TParams>;
export type ParseParamsFn<TPath extends string, TParams> = (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
export type ParseParamsObj<TPath extends string, TParams> = {
    parse?: ParseParamsFn<TPath, TParams>;
};
export type SearchSchemaValidator<TInput, TReturn> = SearchSchemaValidatorObj<TInput, TReturn> | SearchSchemaValidatorFn<TInput, TReturn>;
export type SearchSchemaValidatorObj<TInput, TReturn> = {
    parse?: SearchSchemaValidatorFn<TInput, TReturn>;
};
export type SearchSchemaValidatorFn<TInput, TReturn> = (searchObj: TInput) => TReturn;
export type RouteLoaderFn<TAllParams = {}, TLoaderDeps extends Record<string, any> = {}, TAllContext extends Record<string, any> = AnyContext, TRouteContext extends Record<string, any> = AnyContext, TLoaderData extends any = unknown> = (match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>) => Promise<TLoaderData> | TLoaderData | void;
export interface LoaderFnContext<TAllParams = {}, TLoaderDeps extends Record<string, any> = {}, TAllContext extends Record<string, any> = AnyContext, TRouteContext extends Record<string, any> = AnyContext> {
    abortController: AbortController;
    preload: boolean;
    params: TAllParams;
    deps: TLoaderDeps;
    context: Expand<Assign<TAllContext, TRouteContext>>;
    location: ParsedLocation;
    navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>;
    parentMatchPromise?: Promise<void>;
    cause: 'preload' | 'enter' | 'stay';
    route: Route;
}
export type SearchFilter<T, U = T> = (prev: T) => U;
export type ResolveId<TParentRoute, TCustomId extends string, TPath extends string> = TParentRoute extends {
    id: infer TParentId extends string;
} ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId> : RootRouteId;
export type InferFullSearchSchema<TRoute> = TRoute extends {
    types: {
        fullSearchSchema: infer TFullSearchSchema;
    };
} ? TFullSearchSchema : {};
export type InferFullSearchSchemaInput<TRoute> = TRoute extends {
    types: {
        fullSearchSchemaInput: infer TFullSearchSchemaInput;
    };
} ? TFullSearchSchemaInput : {};
export type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<Assign<Omit<InferFullSearchSchema<TParentRoute>, keyof RootSearchSchema>, TSearchSchema>>;
export type ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed> = Expand<Assign<Omit<InferFullSearchSchemaInput<TParentRoute>, keyof RootSearchSchema>, TSearchSchemaUsed>>;
export interface AnyRoute extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
export type MergeFromFromParent<T, U> = IsAny<T, U, T & U>;
export type ResolveAllParams<TParentRoute extends AnyRoute, TParams extends AnyPathParams> = Record<never, string> extends TParentRoute['types']['allParams'] ? TParams : Expand<UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}>;
export type RouteConstraints = {
    TParentRoute: AnyRoute;
    TPath: string;
    TFullPath: string;
    TCustomId: string;
    TId: string;
    TSearchSchema: AnySearchSchema;
    TFullSearchSchema: AnySearchSchema;
    TParams: Record<string, any>;
    TAllParams: Record<string, any>;
    TParentContext: AnyContext;
    TRouteContext: RouteContext;
    TAllContext: AnyContext;
    TRouterContext: AnyContext;
    TChildren: unknown;
    TRouteTree: AnyRoute;
};
export declare function getRouteApi<TId extends RouteIds<RegisteredRouter['routeTree']>, TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>, TFullSearchSchema extends Record<string, any> = TRoute['types']['fullSearchSchema'], TAllParams extends AnyPathParams = TRoute['types']['allParams'], TAllContext extends Record<string, any> = TRoute['types']['allContext'], TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'], TLoaderData extends any = TRoute['types']['loaderData']>(id: TId): RouteApi<TId, TRoute, TFullSearchSchema, TAllParams, TAllContext, TLoaderDeps, TLoaderData>;
export declare class RouteApi<TId extends RouteIds<RegisteredRouter['routeTree']>, TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>, TFullSearchSchema extends Record<string, any> = TRoute['types']['fullSearchSchema'], TAllParams extends AnyPathParams = TRoute['types']['allParams'], TAllContext extends Record<string, any> = TRoute['types']['allContext'], TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'], TLoaderData extends any = TRoute['types']['loaderData']> {
    id: TId;
    /**
     * @deprecated Use the `getRouteApi` function instead.
     */
    constructor({ id }: {
        id: TId;
    });
    useMatch: <TRouteTree extends AnyRoute = AnyRoute, TRouteMatchState = RouteMatch<TRouteTree, TId, false>, TSelected = TRouteMatchState>(opts?: {
        select?: ((match: TRouteMatchState) => TSelected) | undefined;
    } | undefined) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: ((s: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: ((s: TFullSearchSchema) => TSelected) | undefined;
    } | undefined) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: ((s: TAllParams) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderDeps: <TSelected = TLoaderDeps>(opts?: {
        select?: ((s: TLoaderDeps) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderData: <TSelected = TLoaderData>(opts?: {
        select?: ((s: TLoaderData) => TSelected) | undefined;
    } | undefined) => TSelected;
    useNavigate: () => import("./useNavigate").UseNavigateResult<string>;
    notFound: (opts?: NotFoundError) => NotFoundError;
}
export declare class Route<TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, in out TPath extends RouteConstraints['TPath'] = '/', TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, TCustomId extends RouteConstraints['TCustomId'] = string, TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {}, TSearchSchema extends RouteConstraints['TSearchSchema'] = {}, TSearchSchemaUsed extends Record<string, any> = TSearchSchemaInput extends SearchSchemaInput ? Omit<TSearchSchemaInput, keyof SearchSchemaInput> : TSearchSchema, TFullSearchSchemaInput extends Record<string, any> = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>, TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends RouteConstraints['TParams'] = Expand<Record<ParsePathParams<TPath>, string>>, TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<TParentRoute, TParams>, TRouteContextReturn extends RouteConstraints['TRouteContext'] = RouteContext, in out TRouteContext extends RouteConstraints['TRouteContext'] = [
    TRouteContextReturn
] extends [never] ? RouteContext : TRouteContextReturn, in out TAllContext extends Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends any = unknown, TLoaderData extends any = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn, TChildren extends RouteConstraints['TChildren'] = unknown, TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute> {
    isRoot: TParentRoute extends Route<any> ? true : false;
    options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>;
    parentRoute: TParentRoute;
    id: TId;
    path: TPath;
    fullPath: TFullPath;
    to: TrimPathRight<TFullPath>;
    children?: TChildren;
    originalIndex?: number;
    router?: AnyRouter;
    rank: number;
    lazyFn?: () => Promise<LazyRoute<any>>;
    /**
     * @deprecated Use the `createRoute` function instead.
     */
    constructor(options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>);
    types: {
        parentRoute: TParentRoute;
        path: TPath;
        to: TrimPathRight<TFullPath>;
        fullPath: TFullPath;
        customId: TCustomId;
        id: TId;
        searchSchema: TSearchSchema;
        searchSchemaInput: TSearchSchemaInput;
        searchSchemaUsed: TSearchSchemaUsed;
        fullSearchSchema: TFullSearchSchema;
        fullSearchSchemaInput: TFullSearchSchemaInput;
        params: TParams;
        allParams: TAllParams;
        routeContext: TRouteContext;
        allContext: TAllContext;
        children: TChildren;
        routeTree: TRouteTree;
        routerContext: TRouterContext;
        loaderData: TLoaderData;
        loaderDeps: TLoaderDeps;
    };
    init: (opts: {
        originalIndex: number;
    }) => void;
    addChildren: <TNewChildren extends AnyRoute[]>(children: TNewChildren) => Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TNewChildren, TRouteTree>;
    updateLoader: <TNewLoaderData extends unknown = unknown>(options: {
        loader: RouteLoaderFn<TAllParams, TLoaderDeps, TAllContext, TRouteContext, TNewLoaderData>;
    }) => Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TNewLoaderData, TChildren, TRouteTree, AnyRoute>;
    update: (options: UpdatableRouteOptions<TAllParams, TFullSearchSchema, TLoaderData>) => this;
    lazy: (lazyFn: () => Promise<LazyRoute<any>>) => this;
    useMatch: <TRouteTree_1 extends AnyRoute = AnyRoute, TRouteMatchState = RouteMatch<TRouteTree_1, TId, false>, TSelected = TRouteMatchState>(opts?: {
        select?: ((match: TRouteMatchState) => TSelected) | undefined;
    } | undefined) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: ((search: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: ((search: TFullSearchSchema) => TSelected) | undefined;
    } | undefined) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: ((search: TAllParams) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderDeps: <TSelected = TLoaderDeps>(opts?: {
        select?: ((s: TLoaderDeps) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderData: <TSelected = TLoaderData>(opts?: {
        select?: ((search: TLoaderData) => TSelected) | undefined;
    } | undefined) => TSelected;
}
export declare function createRoute<TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, TPath extends RouteConstraints['TPath'] = '/', TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, TCustomId extends RouteConstraints['TCustomId'] = string, TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {}, TSearchSchema extends RouteConstraints['TSearchSchema'] = {}, TSearchSchemaUsed extends Record<string, any> = TSearchSchemaInput extends SearchSchemaInput ? Omit<TSearchSchemaInput, keyof SearchSchemaInput> : TSearchSchema, TFullSearchSchemaInput extends Record<string, any> = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>, TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends RouteConstraints['TParams'] = Expand<Record<ParsePathParams<TPath>, string>>, TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<TParentRoute, TParams>, TRouteContextReturn extends RouteConstraints['TRouteContext'] = RouteContext, TRouteContext extends RouteConstraints['TRouteContext'] = [
    TRouteContextReturn
] extends [never] ? RouteContext : TRouteContextReturn, TAllContext extends Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends any = unknown, TLoaderData extends any = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn, TChildren extends RouteConstraints['TChildren'] = unknown, TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute>(options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>): Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren, TRouteTree>;
export type AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any>;
export declare function createRootRouteWithContext<TRouterContext extends {}>(): <TSearchSchemaInput extends Record<string, any> = RootSearchSchema, TSearchSchema extends Record<string, any> = RootSearchSchema, TSearchSchemaUsed extends Record<string, any> = RootSearchSchema, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = [TRouteContextReturn] extends [never] ? RouteContext : TRouteContextReturn, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends unknown = unknown, TLoaderData extends unknown = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn>(options?: Omit<RouteOptions<AnyRoute, "__root__", "", TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TSearchSchemaUsed, TSearchSchema, {}, {}, TRouteContextReturn, TRouteContext, TRouterContext, Assign<TRouterContext, TRouteContext>, TLoaderDeps, TLoaderDataReturn, TLoaderData>, "path" | "id" | "stringifyParams" | "parseParams" | "getParentRoute" | "caseSensitive"> | undefined) => RootRoute<TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TRouteContextReturn, TRouteContext, TRouterContext, TLoaderDeps, TLoaderData, [TLoaderData] extends [never] ? undefined : TLoaderData>;
/**
 * @deprecated Use the `createRootRouteWithContext` function instead.
 */
export declare const rootRouteWithContext: typeof createRootRouteWithContext;
export type RootSearchSchema = {
    __TRootSearchSchema__: '__TRootSearchSchema__';
};
export declare class RootRoute<TSearchSchemaInput extends Record<string, any> = RootSearchSchema, TSearchSchema extends Record<string, any> = RootSearchSchema, TSearchSchemaUsed extends Record<string, any> = RootSearchSchema, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = [TRouteContextReturn] extends [never] ? RouteContext : TRouteContextReturn, TRouterContext extends {} = {}, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends any = unknown, TLoaderData extends any = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn> extends Route<any, // TParentRoute
'/', // TPath
'/', // TFullPath
string, // TCustomId
RootRouteId, // TId
TSearchSchemaInput, // TSearchSchemaInput
TSearchSchema, // TSearchSchema
TSearchSchemaUsed, TSearchSchemaUsed, // TFullSearchSchemaInput
TSearchSchema, // TFullSearchSchema
{}, // TParams
{}, // TAllParams
TRouteContextReturn, // TRouteContextReturn
TRouteContext, // TRouteContext
Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext
TRouterContext, // TRouterContext
TLoaderDeps, TLoaderDataReturn, TLoaderData, any, // TChildren
any> {
    /**
     * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
     */
    constructor(options?: Omit<RouteOptions<AnyRoute, // TParentRoute
    RootRouteId, // TCustomId
    '', // TPath
    TSearchSchemaInput, // TSearchSchemaInput
    TSearchSchema, // TSearchSchema
    TSearchSchemaUsed, TSearchSchemaUsed, // TFullSearchSchemaInput
    TSearchSchema, // TFullSearchSchema
    {}, // TParams
    {}, // TAllParams
    TRouteContextReturn, // TRouteContextReturn
    TRouteContext, // TRouteContext
    TRouterContext, Assign<TRouterContext, TRouteContext>, // TAllContext
    TLoaderDeps, TLoaderDataReturn, TLoaderData>, 'path' | 'id' | 'getParentRoute' | 'caseSensitive' | 'parseParams' | 'stringifyParams'>);
}
export declare function createRootRoute<TSearchSchemaInput extends Record<string, any> = RootSearchSchema, TSearchSchema extends Record<string, any> = RootSearchSchema, TSearchSchemaUsed extends Record<string, any> = RootSearchSchema, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = [TRouteContextReturn] extends [never] ? RouteContext : TRouteContextReturn, TRouterContext extends {} = {}, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends any = unknown, TLoaderData extends any = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn>(options?: Omit<RouteOptions<AnyRoute, // TParentRoute
RootRouteId, // TCustomId
'', // TPath
TSearchSchemaInput, // TSearchSchemaInput
TSearchSchema, // TSearchSchema
TSearchSchemaUsed, TSearchSchemaUsed, // TFullSearchSchemaInput
TSearchSchema, // TFullSearchSchema
{}, // TParams
{}, // TAllParams
TRouteContextReturn, // TRouteContextReturn
TRouteContext, // TRouteContext
TRouterContext, Assign<TRouterContext, TRouteContext>, // TAllContext
TLoaderDeps, TLoaderDataReturn, TLoaderData>, 'path' | 'id' | 'getParentRoute' | 'caseSensitive' | 'parseParams' | 'stringifyParams'>): RootRoute<TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TRouteContextReturn, TRouteContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>;
export type ResolveFullPath<TParentRoute extends AnyRoute, TPath extends string, TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>> = TPrefixed extends RootRouteId ? '/' : TPrefixed;
type RoutePrefix<TPrefix extends string, TPath extends string> = string extends TPath ? RootRouteId : TPath extends string ? TPrefix extends RootRouteId ? TPath extends '/' ? '/' : `/${TrimPath<TPath>}` : `${TPrefix}/${TPath}` extends '/' ? '/' : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}` : never;
export type TrimPath<T extends string> = '' extends T ? '' : TrimPathRight<TrimPathLeft<T>>;
export type TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}` ? TrimPathLeft<U> : T extends `/${infer U}` ? TrimPathLeft<U> : T;
export type TrimPathRight<T extends string> = T extends '/' ? '/' : T extends `${infer U}/` ? TrimPathRight<U> : T;
export type RouteMask<TRouteTree extends AnyRoute> = {
    routeTree: TRouteTree;
    from: RoutePaths<TRouteTree>;
    to?: any;
    params?: any;
    search?: any;
    hash?: any;
    state?: any;
    unmaskOnReload?: boolean;
};
export declare function createRouteMask<TRouteTree extends AnyRoute, TFrom extends RoutePaths<TRouteTree>, TTo extends string>(opts: {
    routeTree: TRouteTree;
} & ToSubOptions<TRouteTree, TFrom, TTo>): RouteMask<TRouteTree>;
/**
 * @deprecated Use `ErrorComponentProps` instead.
 */
export type ErrorRouteProps = {
    error: unknown;
    info: {
        componentStack: string;
    };
};
export type ErrorComponentProps = {
    error: unknown;
    info: {
        componentStack: string;
    };
};
export type NotFoundRouteProps = {
    data: unknown;
};
export type ReactNode = any;
export type SyncRouteComponent<TProps> = ((props: TProps) => ReactNode) | React.LazyExoticComponent<(props: TProps) => ReactNode>;
export type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
export type RouteComponent<TProps = any> = SyncRouteComponent<TProps> & AsyncRouteComponent<TProps>;
export type ErrorRouteComponent = RouteComponent<ErrorComponentProps>;
export type NotFoundRouteComponent = SyncRouteComponent<NotFoundRouteProps>;
export declare class NotFoundRoute<TParentRoute extends AnyRootRoute, TSearchSchemaInput extends Record<string, any> = {}, TSearchSchema extends RouteConstraints['TSearchSchema'] = {}, TSearchSchemaUsed extends RouteConstraints['TSearchSchema'] = {}, TFullSearchSchemaInput extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>, TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TRouteContextReturn extends RouteConstraints['TRouteContext'] = AnyContext, TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext, TAllContext extends Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn extends any = unknown, TLoaderData extends any = [TLoaderDataReturn] extends [never] ? undefined : TLoaderDataReturn, TChildren extends RouteConstraints['TChildren'] = unknown, TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute> extends Route<TParentRoute, '/404', '/404', '404', '404', TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, {}, {}, TRouteContextReturn, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren, TRouteTree> {
    constructor(options: Omit<RouteOptions<TParentRoute, string, string, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, {}, {}, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>, 'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'>);
}
export {};
