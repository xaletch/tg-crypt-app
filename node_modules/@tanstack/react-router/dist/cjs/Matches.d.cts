import * as React from 'react';
import { ResolveRelativePath, ToOptions } from './link.cjs';
import { AnyRoute, ReactNode, RootSearchSchema, StaticDataRouteOption } from './route.cjs';
import { AllParams, FullSearchSchema, ParseRoute, RouteById, RouteByPath, RouteIds, RoutePaths } from './routeInfo.cjs';
import { RegisteredRouter, RouterState } from './router.cjs';
import { DeepPartial, Expand, NoInfer, StrictOrFrom } from './utils.cjs';
export declare const matchContext: React.Context<string | undefined>;
export interface RouteMatch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'], TReturnIntersection extends boolean = false> {
    id: string;
    routeId: TRouteId;
    pathname: string;
    params: TReturnIntersection extends false ? RouteById<TRouteTree, TRouteId>['types']['allParams'] : Expand<Partial<AllParams<TRouteTree>>>;
    status: 'pending' | 'success' | 'error' | 'redirected' | 'notFound';
    isFetching: boolean;
    showPending: boolean;
    error: unknown;
    paramsError: unknown;
    searchError: unknown;
    updatedAt: number;
    loadPromise?: Promise<void>;
    loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData'];
    routeContext: RouteById<TRouteTree, TRouteId>['types']['routeContext'];
    context: RouteById<TRouteTree, TRouteId>['types']['allContext'];
    search: TReturnIntersection extends false ? Exclude<RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema'], RootSearchSchema> : Expand<Partial<Omit<FullSearchSchema<TRouteTree>, keyof RootSearchSchema>>>;
    fetchCount: number;
    abortController: AbortController;
    cause: 'preload' | 'enter' | 'stay';
    loaderDeps: RouteById<TRouteTree, TRouteId>['types']['loaderDeps'];
    preload: boolean;
    invalid: boolean;
    pendingPromise?: Promise<void>;
    meta?: JSX.IntrinsicElements['meta'][];
    links?: JSX.IntrinsicElements['link'][];
    scripts?: JSX.IntrinsicElements['script'][];
    headers?: Record<string, string>;
    globalNotFound?: boolean;
    staticData: StaticDataRouteOption;
}
export type AnyRouteMatch = RouteMatch<any, any>;
export declare function Matches(): React.JSX.Element;
export declare function Match({ matchId }: {
    matchId: string;
}): React.JSX.Element;
export declare const Outlet: React.NamedExoticComponent<object>;
export interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    includeSearch?: boolean;
    fuzzy?: boolean;
}
export type UseMatchRouteOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = '', Options extends ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>, RelaxedOptions = Omit<Options, 'search' | 'params'> & DeepPartial<Pick<Options, 'search' | 'params'>>> = RelaxedOptions & MatchRouteOptions;
export declare function useMatchRoute<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(): <TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>, TTo extends string = "", TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = "", TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>>(opts: UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo, ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>, Omit<ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>, "search" | "params"> & {
    search?: DeepPartial<ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>["search"]> | undefined;
    params?: DeepPartial<ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>["params"]> | undefined;
}>) => false | RouteById<TRouteTree, TResolved>["types"]["allParams"];
export type MakeMatchRouteOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''> = UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    children?: ((params?: RouteByPath<TRouteTree, ResolveRelativePath<TFrom, NoInfer<TTo>>>['types']['allParams']) => ReactNode) | React.ReactNode;
};
export declare function MatchRoute<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''>(props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): any;
export declare function getRenderedMatches<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(state: RouterState<TRouteTree>): RouteMatch<TRouteTree, ParseRoute<TRouteTree, TRouteTree>["id"], false>[];
export declare function useMatch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TReturnIntersection extends boolean = false, TRouteMatchState = RouteMatch<TRouteTree, TFrom, TReturnIntersection>, TSelected = TRouteMatchState>(opts: StrictOrFrom<TFrom, TReturnIntersection> & {
    select?: (match: TRouteMatchState) => TSelected;
}): TSelected;
export declare function useMatches<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'], TReturnIntersection extends boolean = false, TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>, T = TRouteMatch[]>(opts?: {
    select?: (matches: TRouteMatch[]) => T;
    experimental_returnIntersection?: TReturnIntersection;
}): T;
export declare function useParentMatches<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'], TReturnIntersection extends boolean = false, TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>, T = TRouteMatch[]>(opts?: {
    select?: (matches: TRouteMatch[]) => T;
    experimental_returnIntersection?: TReturnIntersection;
}): T;
export declare function useChildMatches<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'], TReturnIntersection extends boolean = false, TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>, T = TRouteMatch[]>(opts?: {
    select?: (matches: TRouteMatch[]) => T;
    experimental_returnIntersection?: TReturnIntersection;
}): T;
export declare function useLoaderDeps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<TRouteTree, TFrom>, TSelected = Required<TRouteMatch>['loaderDeps']>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatch) => TSelected;
}): TSelected;
export declare function useLoaderData<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<TRouteTree, TFrom>, TSelected = Required<TRouteMatch>['loaderData']>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatch) => TSelected;
}): TSelected;
export declare function isServerSideError(error: unknown): error is {
    __isServerError: true;
    data: Record<string, any>;
};
export declare function defaultDeserializeError(serializedData: Record<string, any>): any;
