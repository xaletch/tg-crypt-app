"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("react/jsx-runtime");
const React = require("react");
const Matches = require("./Matches.cjs");
const utils = require("./utils.cjs");
const useRouter = require("./useRouter.cjs");
const useRouterState = require("./useRouterState.cjs");
const routerContext = require("./routerContext.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
const useTransition = React__namespace.useTransition || (() => [
  false,
  (cb) => {
    cb();
  }
]);
function RouterProvider({ router, ...rest }) {
  router.update({
    ...router.options,
    ...rest,
    context: {
      ...router.options.context,
      ...rest == null ? void 0 : rest.context
    }
  });
  const matches = router.options.InnerWrap ? /* @__PURE__ */ jsxRuntime.jsx(router.options.InnerWrap, { children: /* @__PURE__ */ jsxRuntime.jsx(Matches.Matches, {}) }) : /* @__PURE__ */ jsxRuntime.jsx(Matches.Matches, {});
  const routerContext$1 = routerContext.getRouterContext();
  const provider = /* @__PURE__ */ jsxRuntime.jsxs(routerContext$1.Provider, { value: router, children: [
    matches,
    /* @__PURE__ */ jsxRuntime.jsx(Transitioner, {})
  ] });
  if (router.options.Wrap) {
    return /* @__PURE__ */ jsxRuntime.jsx(router.options.Wrap, { children: provider });
  }
  return provider;
}
function Transitioner() {
  const router = useRouter.useRouter();
  const mountLoadForRouter = React__namespace.useRef({ router, mounted: false });
  const routerState = useRouterState.useRouterState({
    select: (s) => utils.pick(s, ["isLoading", "location", "resolvedLocation", "isTransitioning"])
  });
  const [isTransitioning, startReactTransition] = useTransition();
  router.startReactTransition = startReactTransition;
  React__namespace.useEffect(() => {
    if (isTransitioning) {
      router.__store.setState((s) => ({
        ...s,
        isTransitioning
      }));
    }
  }, [isTransitioning]);
  const tryLoad = () => {
    const apply = (cb) => {
      if (!routerState.isTransitioning) {
        startReactTransition(() => cb());
      } else {
        cb();
      }
    };
    apply(() => {
      try {
        router.load();
      } catch (err) {
        console.error(err);
      }
    });
  };
  utils.useLayoutEffect(() => {
    const unsub = router.history.subscribe(() => {
      router.latestLocation = router.parseLocation(router.latestLocation);
      if (router.state.location !== router.latestLocation) {
        tryLoad();
      }
    });
    const nextLocation = router.buildLocation({
      to: router.latestLocation.pathname,
      search: true,
      params: true,
      hash: true,
      state: true
    });
    if (routerState.location.href !== nextLocation.href) {
      router.commitLocation({ ...nextLocation, replace: true });
    }
    return () => {
      unsub();
    };
  }, [router.history]);
  utils.useLayoutEffect(() => {
    var _a;
    if (React__namespace.useTransition ? routerState.isTransitioning && !isTransitioning : !routerState.isLoading && routerState.resolvedLocation !== routerState.location) {
      router.emit({
        type: "onResolved",
        fromLocation: routerState.resolvedLocation,
        toLocation: routerState.location,
        pathChanged: routerState.location.href !== ((_a = routerState.resolvedLocation) == null ? void 0 : _a.href)
      });
      if (document.querySelector) {
        if (routerState.location.hash !== "") {
          const el = document.getElementById(
            routerState.location.hash
          );
          if (el) {
            el.scrollIntoView();
          }
        }
      }
      router.__store.setState((s) => ({
        ...s,
        isTransitioning: false,
        resolvedLocation: s.location
      }));
    }
  }, [
    routerState.isTransitioning,
    isTransitioning,
    routerState.isLoading,
    routerState.resolvedLocation,
    routerState.location
  ]);
  utils.useLayoutEffect(() => {
    if (window.__TSR_DEHYDRATED__ || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted) {
      return;
    }
    mountLoadForRouter.current = { router, mounted: true };
    tryLoad();
  }, [router]);
  return null;
}
function getRouteMatch(state, id) {
  return [
    ...state.cachedMatches,
    ...state.pendingMatches ?? [],
    ...state.matches
  ].find((d) => d.id === id);
}
exports.RouterProvider = RouterProvider;
exports.getRouteMatch = getRouteMatch;
//# sourceMappingURL=RouterProvider.cjs.map
