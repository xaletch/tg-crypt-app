"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("path");
const fs = require("fs");
const zod = require("zod");
const configSchema = zod.z.object({
  routeFilePrefix: zod.z.string().optional(),
  routeFileIgnorePrefix: zod.z.string().optional().default("-"),
  routeFileIgnorePattern: zod.z.string().optional(),
  routesDirectory: zod.z.string().optional().default("./src/routes"),
  generatedRouteTree: zod.z.string().optional().default("./src/routeTree.gen.ts"),
  quoteStyle: zod.z.enum(["single", "double"]).optional().default("single"),
  disableTypes: zod.z.boolean().optional().default(false),
  addExtensions: zod.z.boolean().optional().default(false),
  disableLogging: zod.z.boolean().optional().default(false)
});
async function getConfig(inlineConfig = {}, configDirectory) {
  if (configDirectory === void 0) {
    configDirectory = process.cwd();
  }
  const configFilePathJson = path.resolve(configDirectory, "tsr.config.json");
  const exists = fs.existsSync(configFilePathJson);
  let config;
  if (exists) {
    config = configSchema.parse({
      ...JSON.parse(fs.readFileSync(configFilePathJson, "utf-8")),
      ...inlineConfig
    });
  } else {
    config = configSchema.parse(inlineConfig);
  }
  if (config.disableTypes) {
    config.generatedRouteTree = config.generatedRouteTree.replace(
      /\.(ts|tsx)$/,
      ".js"
    );
  }
  return config;
}
exports.configSchema = configSchema;
exports.getConfig = getConfig;
//# sourceMappingURL=config.cjs.map
